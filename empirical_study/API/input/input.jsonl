{"prompt": "def hydrate_time(nanoseconds, tz=None):\n    \"\"\" Hydrator for `Time` and `LocalTime` values.\n\n    :param nanoseconds:\n    :param tz:\n    :return: Time\n    \"\"\"", "current_file": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom datetime import (\n    datetime,\n    time,\n    timedelta,\n)\n\nfrom ....time import (\n    Date,\n    DateTime,\n    Duration,\n    Time,\n)\nfrom ...packstream import Structure\n\n\ndef get_date_unix_epoch():\n    return Date(1970, 1, 1)\n\n\ndef get_date_unix_epoch_ordinal():\n    return get_date_unix_epoch().to_ordinal()\n\n\ndef get_datetime_unix_epoch_utc():\n    from pytz import utc\n    return DateTime(1970, 1, 1, 0, 0, 0, utc)\n\n\ndef hydrate_date(days):\n    \"\"\" Hydrator for `Date` values.\n\n    :param days:\n    :return: Date\n    \"\"\"\n    return Date.from_ordinal(get_date_unix_epoch_ordinal() + days)\n\n\ndef dehydrate_date(value):\n    \"\"\" Dehydrator for `date` values.\n\n    :param value:\n    :type value: Date\n    :return:\n    \"\"\"\n    return Structure(b\"D\", value.toordinal() - get_date_unix_epoch().toordinal())\n\n\n", "metadata": {"ground_truth": "def hydrate_time(nanoseconds, tz=None):\n    \"\"\" Hydrator for `Time` and `LocalTime` values.\n\n    :param nanoseconds:\n    :param tz:\n    :return: Time\n    \"\"\"\n    from pytz import FixedOffset\n    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))\n    minutes, seconds = map(int, divmod(seconds, 60))\n    hours, minutes = map(int, divmod(minutes, 60))\n    t = Time(hours, minutes, seconds, nanoseconds)\n    if tz is None:\n        return t\n    tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n    zone = FixedOffset(tz_offset_minutes)\n    return zone.localize(t)\n", "fpath_tuple": ["neo4j", "_codec", "hydration", "v1", "temporal.py"], "function_name": "hydrate_time", "lineno": 66, "context_start_lineno": 0, "_id": "62e60f43d76274f8a4026e28", "task_id": "neo4j/id0"}}
{"prompt": "def dehydrate_timedelta(value):\n    \"\"\" Dehydrator for `timedelta` values.\n\n    :param value:\n    :type value: timedelta\n    :return:\n    \"\"\"", "current_file": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom datetime import (\n    datetime,\n    time,\n    timedelta,\n)\n\nfrom ....time import (\n    Date,\n    DateTime,\n    Duration,\n    Time,\n)\nfrom ...packstream import Structure\n\n\ndef get_date_unix_epoch():\n    return Date(1970, 1, 1)\n\n\ndef get_date_unix_epoch_ordinal():\n    return get_date_unix_epoch().to_ordinal()\n\n\ndef get_datetime_unix_epoch_utc():\n    from pytz import utc\n    return DateTime(1970, 1, 1, 0, 0, 0, utc)\n\n\ndef hydrate_date(days):\n    \"\"\" Hydrator for `Date` values.\n\n    :param days:\n    :return: Date\n    \"\"\"\n    return Date.from_ordinal(get_date_unix_epoch_ordinal() + days)\n\n\ndef dehydrate_date(value):\n    \"\"\" Dehydrator for `date` values.\n\n    :param value:\n    :type value: Date\n    :return:\n    \"\"\"\n    return Structure(b\"D\", value.toordinal() - get_date_unix_epoch().toordinal())\n\n\ndef hydrate_time(nanoseconds, tz=None):\n    \"\"\" Hydrator for `Time` and `LocalTime` values.\n\n    :param nanoseconds:\n    :param tz:\n    :return: Time\n    \"\"\"\n    from pytz import FixedOffset\n    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))\n    minutes, seconds = map(int, divmod(seconds, 60))\n    hours, minutes = map(int, divmod(minutes, 60))\n    t = Time(hours, minutes, seconds, nanoseconds)\n    if tz is None:\n        return t\n    tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n    zone = FixedOffset(tz_offset_minutes)\n    return zone.localize(t)\n\n\ndef dehydrate_time(value):\n    \"\"\" Dehydrator for `time` values.\n\n    :param value:\n    :type value: Time\n    :return:\n    \"\"\"\n    if isinstance(value, Time):\n        nanoseconds = value.ticks\n    elif isinstance(value, time):\n        nanoseconds = (3600000000000 * value.hour + 60000000000 * value.minute +\n                       1000000000 * value.second + 1000 * value.microsecond)\n    else:\n        raise TypeError(\"Value must be a neo4j.time.Time or a datetime.time\")\n    if value.tzinfo:\n        return Structure(b\"T\", nanoseconds,\n                         int(value.tzinfo.utcoffset(value).total_seconds()))\n    else:\n        return Structure(b\"t\", nanoseconds)\n\n\ndef hydrate_datetime(seconds, nanoseconds, tz=None):\n    \"\"\" Hydrator for `DateTime` and `LocalDateTime` values.\n\n    :param seconds:\n    :param nanoseconds:\n    :param tz:\n    :return: datetime\n    \"\"\"\n    from pytz import (\n        FixedOffset,\n        timezone,\n    )\n    minutes, seconds = map(int, divmod(seconds, 60))\n    hours, minutes = map(int, divmod(minutes, 60))\n    days, hours = map(int, divmod(hours, 24))\n    t = DateTime.combine(\n        Date.from_ordinal(get_date_unix_epoch_ordinal() + days),\n        Time(hours, minutes, seconds, nanoseconds)\n    )\n    if tz is None:\n        return t\n    if isinstance(tz, int):\n        tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n        zone = FixedOffset(tz_offset_minutes)\n    else:\n        zone = timezone(tz)\n    return zone.localize(t)\n\n\ndef dehydrate_datetime(value):\n    \"\"\" Dehydrator for `datetime` values.\n\n    :param value:\n    :type value: datetime or DateTime\n    :return:\n    \"\"\"\n\n    def seconds_and_nanoseconds(dt):\n        if isinstance(dt, datetime):\n            dt = DateTime.from_native(dt)\n        zone_epoch = DateTime(1970, 1, 1, tzinfo=dt.tzinfo)\n        dt_clock_time = dt.to_clock_time()\n        zone_epoch_clock_time = zone_epoch.to_clock_time()\n        t = dt_clock_time - zone_epoch_clock_time\n        return t.seconds, t.nanoseconds\n\n    tz = value.tzinfo\n    if tz is None:\n        # without time zone\n        from pytz import utc\n        value = utc.localize(value)\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"d\", seconds, nanoseconds)\n    elif hasattr(tz, \"zone\") and tz.zone and isinstance(tz.zone, str):\n        # with named pytz time zone\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"f\", seconds, nanoseconds, tz.zone)\n    elif hasattr(tz, \"key\") and tz.key and isinstance(tz.key, str):\n        # with named zoneinfo (Python 3.9+) time zone\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"f\", seconds, nanoseconds, tz.key)\n    else:\n        # with time offset\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"F\", seconds, nanoseconds,\n                         int(tz.utcoffset(value).total_seconds()))\n\n\ndef hydrate_duration(months, days, seconds, nanoseconds):\n    \"\"\" Hydrator for `Duration` values.\n\n    :param months:\n    :param days:\n    :param seconds:\n    :param nanoseconds:\n    :return: `duration` namedtuple\n    \"\"\"\n    return Duration(months=months, days=days, seconds=seconds, nanoseconds=nanoseconds)\n\n\ndef dehydrate_duration(value):\n    \"\"\" Dehydrator for `duration` values.\n\n    :param value:\n    :type value: Duration\n    :return:\n    \"\"\"\n    return Structure(b\"E\", value.months, value.days, value.seconds, value.nanoseconds)\n\n\n", "metadata": {"ground_truth": "def dehydrate_timedelta(value):\n    \"\"\" Dehydrator for `timedelta` values.\n\n    :param value:\n    :type value: timedelta\n    :return:\n    \"\"\"\n    months = 0\n    days = value.days\n    seconds = value.seconds\n    nanoseconds = 1000 * value.microseconds\n    return Structure(b\"E\", months, days, seconds, nanoseconds)\n", "fpath_tuple": ["neo4j", "_codec", "hydration", "v1", "temporal.py"], "function_name": "dehydrate_timedelta", "lineno": 196, "context_start_lineno": 0, "_id": "62e60f3bd76274f8a4026e10", "task_id": "neo4j/id1"}}
{"prompt": "def dehydrate_time(value):\n    \"\"\" Dehydrator for `time` values.\n\n    :param value:\n    :type value: Time\n    :return:\n    \"\"\"", "current_file": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom datetime import (\n    datetime,\n    time,\n    timedelta,\n)\n\nfrom ....time import (\n    Date,\n    DateTime,\n    Duration,\n    Time,\n)\nfrom ...packstream import Structure\n\n\ndef get_date_unix_epoch():\n    return Date(1970, 1, 1)\n\n\ndef get_date_unix_epoch_ordinal():\n    return get_date_unix_epoch().to_ordinal()\n\n\ndef get_datetime_unix_epoch_utc():\n    from pytz import utc\n    return DateTime(1970, 1, 1, 0, 0, 0, utc)\n\n\ndef hydrate_date(days):\n    \"\"\" Hydrator for `Date` values.\n\n    :param days:\n    :return: Date\n    \"\"\"\n    return Date.from_ordinal(get_date_unix_epoch_ordinal() + days)\n\n\ndef dehydrate_date(value):\n    \"\"\" Dehydrator for `date` values.\n\n    :param value:\n    :type value: Date\n    :return:\n    \"\"\"\n    return Structure(b\"D\", value.toordinal() - get_date_unix_epoch().toordinal())\n\n\ndef hydrate_time(nanoseconds, tz=None):\n    \"\"\" Hydrator for `Time` and `LocalTime` values.\n\n    :param nanoseconds:\n    :param tz:\n    :return: Time\n    \"\"\"\n    from pytz import FixedOffset\n    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))\n    minutes, seconds = map(int, divmod(seconds, 60))\n    hours, minutes = map(int, divmod(minutes, 60))\n    t = Time(hours, minutes, seconds, nanoseconds)\n    if tz is None:\n        return t\n    tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n    zone = FixedOffset(tz_offset_minutes)\n    return zone.localize(t)\n\n\n", "metadata": {"ground_truth": "def dehydrate_time(value):\n    \"\"\" Dehydrator for `time` values.\n\n    :param value:\n    :type value: Time\n    :return:\n    \"\"\"\n    if isinstance(value, Time):\n        nanoseconds = value.ticks\n    elif isinstance(value, time):\n        nanoseconds = (3600000000000 * value.hour + 60000000000 * value.minute +\n                       1000000000 * value.second + 1000 * value.microsecond)\n    else:\n        raise TypeError(\"Value must be a neo4j.time.Time or a datetime.time\")\n    if value.tzinfo:\n        return Structure(b\"T\", nanoseconds,\n                         int(value.tzinfo.utcoffset(value).total_seconds()))\n    else:\n        return Structure(b\"t\", nanoseconds)\n", "fpath_tuple": ["neo4j", "_codec", "hydration", "v1", "temporal.py"], "function_name": "dehydrate_time", "lineno": 85, "context_start_lineno": 0, "_id": "62e60f37d76274f8a4026dfd", "task_id": "neo4j/id2"}}
{"prompt": "def dehydrate_point(value):\n    \"\"\" Dehydrator for Point data.\n\n    :param value:\n    :type value: Point\n    :return:\n    \"\"\"", "current_file": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom ...._spatial import (\n    Point,\n    srid_table,\n)\nfrom ...packstream import Structure\n\n\ndef hydrate_point(srid, *coordinates):\n    \"\"\" Create a new instance of a Point subclass from a raw\n    set of fields. The subclass chosen is determined by the\n    given SRID; a ValueError will be raised if no such\n    subclass can be found.\n    \"\"\"\n    try:\n        point_class, dim = srid_table[srid]\n    except KeyError:\n        point = Point(coordinates)\n        point.srid = srid\n        return point\n    else:\n        if len(coordinates) != dim:\n            raise ValueError(\"SRID %d requires %d coordinates (%d provided)\" % (srid, dim, len(coordinates)))\n        return point_class(coordinates)\n\n\n", "metadata": {"ground_truth": "def dehydrate_point(value):\n    \"\"\" Dehydrator for Point data.\n\n    :param value:\n    :type value: Point\n    :return:\n    \"\"\"\n    dim = len(value)\n    if dim == 2:\n        return Structure(b\"X\", value.srid, *value)\n    elif dim == 3:\n        return Structure(b\"Y\", value.srid, *value)\n    else:\n        raise ValueError(\"Cannot dehydrate Point with %d dimensions\" % dim)\n", "fpath_tuple": ["neo4j", "_codec", "hydration", "v1", "spatial.py"], "function_name": "dehydrate_point", "lineno": 44, "context_start_lineno": 0, "_id": "62e60f33d76274f8a4026de9", "task_id": "neo4j/id3"}}
{"prompt": "    def keys(self):\n        \"\"\" Return the keys of the record.\n\n        :return: list of key names\n        \"\"\"", "current_file": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom abc import (\n    ABCMeta,\n    abstractmethod,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n    Set,\n)\nfrom functools import reduce\nfrom operator import xor as xor_operator\n\nfrom ._codec.hydration import BrokenHydrationObject\nfrom ._conf import iter_items\nfrom ._meta import deprecated\nfrom .exceptions import BrokenRecordError\nfrom .graph import (\n    Node,\n    Path,\n    Relationship,\n)\n\n\nclass Record(tuple, Mapping):\n    \"\"\" A :class:`.Record` is an immutable ordered collection of key-value\n    pairs. It is generally closer to a :py:class:`namedtuple` than to a\n    :py:class:`OrderedDict` in as much as iteration of the collection will\n    yield values rather than keys.\n    \"\"\"\n\n    __keys = None\n\n    def __new__(cls, iterable=()):\n        keys = []\n        values = []\n        for key, value in iter_items(iterable):\n            keys.append(key)\n            values.append(value)\n        inst = tuple.__new__(cls, values)\n        inst.__keys = tuple(keys)\n        return inst\n\n    def _broken_record_error(self, index):\n        return BrokenRecordError(\n            f\"Record contains broken data at {index} ('{self.__keys[index]}')\"\n        )\n\n    def _super_getitem_single(self, index):\n        value = super().__getitem__(index)\n        if isinstance(value, BrokenHydrationObject):\n            raise self._broken_record_error(index) from value.error\n        return value\n\n    def __repr__(self):\n        return \"<%s %s>\" % (\n            self.__class__.__name__,\n            \" \".join(\"%s=%r\" % (field, value)\n                     for field, value in zip(self.__keys, super().__iter__()))\n        )\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __eq__(self, other):\n        \"\"\" In order to be flexible regarding comparison, the equality rules\n        for a record permit comparison with any other Sequence or Mapping.\n\n        :param other:\n        :return:\n        \"\"\"\n        compare_as_sequence = isinstance(other, Sequence)\n        compare_as_mapping = isinstance(other, Mapping)\n        if compare_as_sequence and compare_as_mapping:\n            return list(self) == list(other) and dict(self) == dict(other)\n        elif compare_as_sequence:\n            return list(self) == list(other)\n        elif compare_as_mapping:\n            return dict(self) == dict(other)\n        else:\n            return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return reduce(xor_operator, map(hash, self.items()))\n\n    def __iter__(self):\n        for i, v in enumerate(super().__iter__()):\n            if isinstance(v, BrokenHydrationObject):\n                raise self._broken_record_error(i) from v.error\n            yield v\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            keys = self.__keys[key]\n            values = super().__getitem__(key)\n            return self.__class__(zip(keys, values))\n        try:\n            index = self.index(key)\n        except IndexError:\n            return None\n        else:\n            return self._super_getitem_single(index)\n\n    # TODO: 6.0 - remove\n    @deprecated(\"This method is deprecated and will be removed in the future.\")\n    def __getslice__(self, start, stop):\n        key = slice(start, stop)\n        keys = self.__keys[key]\n        values = tuple(self)[key]\n        return self.__class__(zip(keys, values))\n\n    def get(self, key, default=None):\n        \"\"\" Obtain a value from the record by key, returning a default\n        value if the key does not exist.\n\n        :param key: a key\n        :param default: default value\n        :return: a value\n        \"\"\"\n        try:\n            index = self.__keys.index(str(key))\n        except ValueError:\n            return default\n        if 0 <= index < len(self):\n            return self._super_getitem_single(index)\n        else:\n            return default\n\n    def index(self, key):\n        \"\"\" Return the index of the given item.\n\n        :param key: a key\n        :return: index\n        :rtype: int\n        \"\"\"\n        if isinstance(key, int):\n            if 0 <= key < len(self.__keys):\n                return key\n            raise IndexError(key)\n        elif isinstance(key, str):\n            try:\n                return self.__keys.index(key)\n            except ValueError:\n                raise KeyError(key)\n        else:\n            raise TypeError(key)\n\n    def value(self, key=0, default=None):\n        \"\"\" Obtain a single value from the record by index or key. If no\n        index or key is specified, the first value is returned. If the\n        specified item does not exist, the default value is returned.\n\n        :param key: an index or key\n        :param default: default value\n        :return: a single value\n        \"\"\"\n        try:\n            index = self.index(key)\n        except (IndexError, KeyError):\n            return default\n        else:\n            return self[index]\n\n", "metadata": {"ground_truth": "    def keys(self):\n        \"\"\" Return the keys of the record.\n\n        :return: list of key names\n        \"\"\"\n        return list(self.__keys)\n", "fpath_tuple": ["neo4j", "_data.py"], "function_name": "keys", "lineno": 184, "context_start_lineno": 0, "_id": "62e60ed4d76274f8a4026da0", "task_id": "neo4j/id4"}}
{"prompt": "    @classmethod\n    def protocol_handlers(cls, protocol_version=None):\n        \"\"\" Return a dictionary of available Bolt protocol handlers,\n        keyed by version tuple. If an explicit protocol version is\n        provided, the dictionary will contain either zero or one items,\n        depending on whether that version is supported. If no protocol\n        version is provided, all available versions will be returned.\n\n        :param protocol_version: tuple identifying a specific protocol\n            version (e.g. (3, 5)) or None\n        :return: dictionary of version tuple to handler class for all\n            relevant and supported protocol versions\n        :raise TypeError: if protocol version is not passed in a tuple\n        \"\"\"", "current_file": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport abc\nimport asyncio\nfrom collections import deque\nfrom logging import getLogger\nfrom time import perf_counter\n\nfrom ..._async_compat.network import BoltSocket\nfrom ..._async_compat.util import Util\nfrom ..._codec.hydration import v1 as hydration_v1\nfrom ..._codec.packstream import v1 as packstream_v1\nfrom ..._conf import PoolConfig\nfrom ..._exceptions import (\n    BoltError,\n    BoltHandshakeError,\n    SocketDeadlineExceeded,\n)\nfrom ..._meta import get_user_agent\nfrom ...addressing import Address\nfrom ...api import (\n    ServerInfo,\n    Version,\n)\nfrom ...exceptions import (\n    AuthError,\n    DriverError,\n    IncompleteCommit,\n    ServiceUnavailable,\n    SessionExpired,\n)\nfrom ._common import (\n    CommitResponse,\n    Inbox,\n    Outbox,\n)\n\n\n# Set up logger\nlog = getLogger(\"neo4j\")\n\n\nclass Bolt:\n    \"\"\" Server connection for Bolt protocol.\n\n    A :class:`.Bolt` should be constructed following a\n    successful .open()\n\n    Bolt handshake and takes the socket over which\n    the handshake was carried out.\n    \"\"\"\n\n    # TODO: let packer/unpacker know of hydration (give them hooks?)\n    # TODO: make sure query parameter dehydration gets clear error message.\n\n    PACKER_CLS = packstream_v1.Packer\n    UNPACKER_CLS = packstream_v1.Unpacker\n    HYDRATION_HANDLER_CLS = hydration_v1.HydrationHandler\n\n    MAGIC_PREAMBLE = b\"\\x60\\x60\\xB0\\x17\"\n\n    PROTOCOL_VERSION = None\n\n    # flag if connection needs RESET to go back to READY state\n    is_reset = False\n\n    # The socket\n    in_use = False\n\n    # When the connection was last put back into the pool\n    idle_since = float(\"-inf\")\n\n    # The socket\n    _closing = False\n    _closed = False\n\n    # The socket\n    _defunct = False\n\n    #: The pool of which this connection is a member\n    pool = None\n\n    # Store the id of the most recent ran query to be able to reduce sent bits by\n    # using the default (-1) to refer to the most recent query when pulling\n    # results for it.\n    most_recent_qid = None\n\n    def __init__(self, unresolved_address, sock, max_connection_lifetime, *,\n                 auth=None, user_agent=None, routing_context=None):\n        self.unresolved_address = unresolved_address\n        self.socket = sock\n        self.local_port = self.socket.getsockname()[1]\n        self.server_info = ServerInfo(Address(sock.getpeername()),\n                                      self.PROTOCOL_VERSION)\n        # so far `connection.recv_timeout_seconds` is the only available\n        # configuration hint that exists. Therefore, all hints can be stored at\n        # connection level. This might change in the future.\n        self.configuration_hints = {}\n        self.patch = {}\n        self.outbox = Outbox(\n            self.socket, on_error=self._set_defunct_write,\n            packer_cls=self.PACKER_CLS\n        )\n        self.inbox = Inbox(\n            self.socket, on_error=self._set_defunct_read,\n            unpacker_cls=self.UNPACKER_CLS\n        )\n        self.hydration_handler = self.HYDRATION_HANDLER_CLS()\n        self.responses = deque()\n        self._max_connection_lifetime = max_connection_lifetime\n        self._creation_timestamp = perf_counter()\n        self.routing_context = routing_context\n        self.idle_since = perf_counter()\n\n        # Determine the user agent\n        if user_agent:\n            self.user_agent = user_agent\n        else:\n            self.user_agent = get_user_agent()\n\n        # Determine auth details\n        if not auth:\n            self.auth_dict = {}\n        elif isinstance(auth, tuple) and 2 <= len(auth) <= 3:\n            from neo4j import Auth\n            self.auth_dict = vars(Auth(\"basic\", *auth))\n        else:\n            try:\n                self.auth_dict = vars(auth)\n            except (KeyError, TypeError):\n                raise AuthError(\"Cannot determine auth details from %r\" % auth)\n\n        # Check for missing password\n        try:\n            credentials = self.auth_dict[\"credentials\"]\n        except KeyError:\n            pass\n        else:\n            if credentials is None:\n                raise AuthError(\"Password cannot be None\")\n\n    def __del__(self):\n        if not asyncio.iscoroutinefunction(self.close):\n            self.close()\n\n    @property\n    @abc.abstractmethod\n    def supports_multiple_results(self):\n        \"\"\" Boolean flag to indicate if the connection version supports multiple\n        queries to be buffered on the server side (True) or if all results need\n        to be eagerly pulled before sending the next RUN (False).\n        \"\"\"\n        pass\n\n    @property\n    @abc.abstractmethod\n    def supports_multiple_databases(self):\n        \"\"\" Boolean flag to indicate if the connection version supports multiple\n        databases.\n        \"\"\"\n        pass\n\n", "metadata": {"ground_truth": "    @classmethod\n    def protocol_handlers(cls, protocol_version=None):\n        \"\"\" Return a dictionary of available Bolt protocol handlers,\n        keyed by version tuple. If an explicit protocol version is\n        provided, the dictionary will contain either zero or one items,\n        depending on whether that version is supported. If no protocol\n        version is provided, all available versions will be returned.\n\n        :param protocol_version: tuple identifying a specific protocol\n            version (e.g. (3, 5)) or None\n        :return: dictionary of version tuple to handler class for all\n            relevant and supported protocol versions\n        :raise TypeError: if protocol version is not passed in a tuple\n        \"\"\"\n\n        # Carry out Bolt subclass imports locally to avoid circular dependency issues.\n        from ._bolt3 import Bolt3\n        from ._bolt4 import (\n            Bolt4x1,\n            Bolt4x2,\n            Bolt4x3,\n            Bolt4x4,\n        )\n        from ._bolt5 import Bolt5x0\n\n        handlers = {\n            Bolt3.PROTOCOL_VERSION: Bolt3,\n            # 4.0 unsupported because no space left in the handshake\n            Bolt4x1.PROTOCOL_VERSION: Bolt4x1,\n            Bolt4x2.PROTOCOL_VERSION: Bolt4x2,\n            Bolt4x3.PROTOCOL_VERSION: Bolt4x3,\n            Bolt4x4.PROTOCOL_VERSION: Bolt4x4,\n            Bolt5x0.PROTOCOL_VERSION: Bolt5x0,\n        }\n\n        if protocol_version is None:\n            return handlers\n\n        if not isinstance(protocol_version, tuple):\n            raise TypeError(\"Protocol version must be specified as a tuple\")\n\n        if protocol_version in handlers:\n            return {protocol_version: handlers[protocol_version]}\n\n        return {}\n", "fpath_tuple": ["neo4j", "_sync", "io", "_bolt.py"], "function_name": "protocol_handlers", "lineno": 179, "context_start_lineno": 0, "_id": "62e60ecfd76274f8a4026d6a", "task_id": "neo4j/id5"}}
{"prompt": "def unit_of_work(metadata=None, timeout=None):\n    \"\"\"This function is a decorator for transaction functions that allows extra control over how the transaction is carried out.\n\n    For example, a timeout may be applied::\n\n        from neo4j import unit_of_work\n\n        @unit_of_work(timeout=100)\n        def count_people_tx(tx):\n            result = tx.run(\"MATCH (a:Person) RETURN count(a) AS persons\")\n            record = result.single()\n            return record[\"persons\"]\n\n    :param metadata:\n        a dictionary with metadata.\n        Specified metadata will be attached to the executing transaction and visible in the output of ``dbms.listQueries`` and ``dbms.listTransactions`` procedures.\n        It will also get logged to the ``query.log``.\n        This functionality makes it easier to tag transactions and is equivalent to ``dbms.setTXMetaData`` procedure, see https://neo4j.com/docs/operations-manual/current/reference/procedures/ for procedure reference.\n    :type metadata: dict\n\n    :param timeout:\n        the transaction timeout in seconds.\n        Transactions that execute longer than the configured timeout will be terminated by the database.\n        This functionality allows to limit query/transaction execution time.\n        Specified timeout overrides the default timeout configured in the database using ``dbms.transaction.timeout`` setting.\n        Value should not represent a negative duration.\n        A zero duration will make the transaction execute indefinitely.\n        None will use the default timeout configured in the database.\n    :type timeout: float or :const:`None`\n    \"\"\"", "current_file": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nclass Query:\n    \"\"\" Create a new query.\n\n    :param text: The query text.\n    :type text: str\n    :param metadata: metadata attached to the query.\n    :type metadata: dict\n    :param timeout: seconds.\n    :type timeout: float or :const:`None`\n    \"\"\"\n    def __init__(self, text, metadata=None, timeout=None):\n        self.text = text\n\n        self.metadata = metadata\n        self.timeout = timeout\n\n    def __str__(self):\n        return str(self.text)\n\n\n", "metadata": {"ground_truth": "def unit_of_work(metadata=None, timeout=None):\n    \"\"\"This function is a decorator for transaction functions that allows extra control over how the transaction is carried out.\n\n    For example, a timeout may be applied::\n\n        from neo4j import unit_of_work\n\n        @unit_of_work(timeout=100)\n        def count_people_tx(tx):\n            result = tx.run(\"MATCH (a:Person) RETURN count(a) AS persons\")\n            record = result.single()\n            return record[\"persons\"]\n\n    :param metadata:\n        a dictionary with metadata.\n        Specified metadata will be attached to the executing transaction and visible in the output of ``dbms.listQueries`` and ``dbms.listTransactions`` procedures.\n        It will also get logged to the ``query.log``.\n        This functionality makes it easier to tag transactions and is equivalent to ``dbms.setTXMetaData`` procedure, see https://neo4j.com/docs/operations-manual/current/reference/procedures/ for procedure reference.\n    :type metadata: dict\n\n    :param timeout:\n        the transaction timeout in seconds.\n        Transactions that execute longer than the configured timeout will be terminated by the database.\n        This functionality allows to limit query/transaction execution time.\n        Specified timeout overrides the default timeout configured in the database using ``dbms.transaction.timeout`` setting.\n        Value should not represent a negative duration.\n        A zero duration will make the transaction execute indefinitely.\n        None will use the default timeout configured in the database.\n    :type timeout: float or :const:`None`\n    \"\"\"\n\n    def wrapper(f):\n\n        def wrapped(*args, **kwargs):\n            return f(*args, **kwargs)\n\n        wrapped.metadata = metadata\n        wrapped.timeout = timeout\n        return wrapped\n\n    return wrapper\n", "fpath_tuple": ["neo4j", "work", "query.py"], "function_name": "unit_of_work", "lineno": 39, "context_start_lineno": 0, "_id": "62e60e49d76274f8a4026d25", "task_id": "neo4j/id6"}}
{"prompt": "    def index(self, key):\n        \"\"\" Return the index of the given item.\n\n        :param key: a key\n        :return: index\n        :rtype: int\n        \"\"\"", "current_file": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom abc import (\n    ABCMeta,\n    abstractmethod,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n    Set,\n)\nfrom functools import reduce\nfrom operator import xor as xor_operator\n\nfrom ._codec.hydration import BrokenHydrationObject\nfrom ._conf import iter_items\nfrom ._meta import deprecated\nfrom .exceptions import BrokenRecordError\nfrom .graph import (\n    Node,\n    Path,\n    Relationship,\n)\n\n\nclass Record(tuple, Mapping):\n    \"\"\" A :class:`.Record` is an immutable ordered collection of key-value\n    pairs. It is generally closer to a :py:class:`namedtuple` than to a\n    :py:class:`OrderedDict` in as much as iteration of the collection will\n    yield values rather than keys.\n    \"\"\"\n\n    __keys = None\n\n    def __new__(cls, iterable=()):\n        keys = []\n        values = []\n        for key, value in iter_items(iterable):\n            keys.append(key)\n            values.append(value)\n        inst = tuple.__new__(cls, values)\n        inst.__keys = tuple(keys)\n        return inst\n\n    def _broken_record_error(self, index):\n        return BrokenRecordError(\n            f\"Record contains broken data at {index} ('{self.__keys[index]}')\"\n        )\n\n    def _super_getitem_single(self, index):\n        value = super().__getitem__(index)\n        if isinstance(value, BrokenHydrationObject):\n            raise self._broken_record_error(index) from value.error\n        return value\n\n    def __repr__(self):\n        return \"<%s %s>\" % (\n            self.__class__.__name__,\n            \" \".join(\"%s=%r\" % (field, value)\n                     for field, value in zip(self.__keys, super().__iter__()))\n        )\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __eq__(self, other):\n        \"\"\" In order to be flexible regarding comparison, the equality rules\n        for a record permit comparison with any other Sequence or Mapping.\n\n        :param other:\n        :return:\n        \"\"\"\n        compare_as_sequence = isinstance(other, Sequence)\n        compare_as_mapping = isinstance(other, Mapping)\n        if compare_as_sequence and compare_as_mapping:\n            return list(self) == list(other) and dict(self) == dict(other)\n        elif compare_as_sequence:\n            return list(self) == list(other)\n        elif compare_as_mapping:\n            return dict(self) == dict(other)\n        else:\n            return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return reduce(xor_operator, map(hash, self.items()))\n\n    def __iter__(self):\n        for i, v in enumerate(super().__iter__()):\n            if isinstance(v, BrokenHydrationObject):\n                raise self._broken_record_error(i) from v.error\n            yield v\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            keys = self.__keys[key]\n            values = super().__getitem__(key)\n            return self.__class__(zip(keys, values))\n        try:\n            index = self.index(key)\n        except IndexError:\n            return None\n        else:\n            return self._super_getitem_single(index)\n\n    # TODO: 6.0 - remove\n    @deprecated(\"This method is deprecated and will be removed in the future.\")\n    def __getslice__(self, start, stop):\n        key = slice(start, stop)\n        keys = self.__keys[key]\n        values = tuple(self)[key]\n        return self.__class__(zip(keys, values))\n\n    def get(self, key, default=None):\n        \"\"\" Obtain a value from the record by key, returning a default\n        value if the key does not exist.\n\n        :param key: a key\n        :param default: default value\n        :return: a value\n        \"\"\"\n        try:\n            index = self.__keys.index(str(key))\n        except ValueError:\n            return default\n        if 0 <= index < len(self):\n            return self._super_getitem_single(index)\n        else:\n            return default\n\n", "metadata": {"ground_truth": "    def index(self, key):\n        \"\"\" Return the index of the given item.\n\n        :param key: a key\n        :return: index\n        :rtype: int\n        \"\"\"\n        if isinstance(key, int):\n            if 0 <= key < len(self.__keys):\n                return key\n            raise IndexError(key)\n        elif isinstance(key, str):\n            try:\n                return self.__keys.index(key)\n            except ValueError:\n                raise KeyError(key)\n        else:\n            raise TypeError(key)\n", "fpath_tuple": ["neo4j", "_data.py"], "function_name": "index", "lineno": 149, "context_start_lineno": 0, "_id": "62e60e05d76274f8a4026cfd", "task_id": "neo4j/id7"}}
{"prompt": "    def values(self, *keys):\n        \"\"\" Return the values of the record, optionally filtering to\n        include only certain values by index or key.\n\n        :param keys: indexes or keys of the items to include; if none\n                     are provided, all values will be included\n        :return: list of values\n        :rtype: list\n        \"\"\"", "current_file": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom abc import (\n    ABCMeta,\n    abstractmethod,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n    Set,\n)\nfrom functools import reduce\nfrom operator import xor as xor_operator\n\nfrom ._codec.hydration import BrokenHydrationObject\nfrom ._conf import iter_items\nfrom ._meta import deprecated\nfrom .exceptions import BrokenRecordError\nfrom .graph import (\n    Node,\n    Path,\n    Relationship,\n)\n\n\nclass Record(tuple, Mapping):\n    \"\"\" A :class:`.Record` is an immutable ordered collection of key-value\n    pairs. It is generally closer to a :py:class:`namedtuple` than to a\n    :py:class:`OrderedDict` in as much as iteration of the collection will\n    yield values rather than keys.\n    \"\"\"\n\n    __keys = None\n\n    def __new__(cls, iterable=()):\n        keys = []\n        values = []\n        for key, value in iter_items(iterable):\n            keys.append(key)\n            values.append(value)\n        inst = tuple.__new__(cls, values)\n        inst.__keys = tuple(keys)\n        return inst\n\n    def _broken_record_error(self, index):\n        return BrokenRecordError(\n            f\"Record contains broken data at {index} ('{self.__keys[index]}')\"\n        )\n\n    def _super_getitem_single(self, index):\n        value = super().__getitem__(index)\n        if isinstance(value, BrokenHydrationObject):\n            raise self._broken_record_error(index) from value.error\n        return value\n\n    def __repr__(self):\n        return \"<%s %s>\" % (\n            self.__class__.__name__,\n            \" \".join(\"%s=%r\" % (field, value)\n                     for field, value in zip(self.__keys, super().__iter__()))\n        )\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __eq__(self, other):\n        \"\"\" In order to be flexible regarding comparison, the equality rules\n        for a record permit comparison with any other Sequence or Mapping.\n\n        :param other:\n        :return:\n        \"\"\"\n        compare_as_sequence = isinstance(other, Sequence)\n        compare_as_mapping = isinstance(other, Mapping)\n        if compare_as_sequence and compare_as_mapping:\n            return list(self) == list(other) and dict(self) == dict(other)\n        elif compare_as_sequence:\n            return list(self) == list(other)\n        elif compare_as_mapping:\n            return dict(self) == dict(other)\n        else:\n            return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return reduce(xor_operator, map(hash, self.items()))\n\n    def __iter__(self):\n        for i, v in enumerate(super().__iter__()):\n            if isinstance(v, BrokenHydrationObject):\n                raise self._broken_record_error(i) from v.error\n            yield v\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            keys = self.__keys[key]\n            values = super().__getitem__(key)\n            return self.__class__(zip(keys, values))\n        try:\n            index = self.index(key)\n        except IndexError:\n            return None\n        else:\n            return self._super_getitem_single(index)\n\n    # TODO: 6.0 - remove\n    @deprecated(\"This method is deprecated and will be removed in the future.\")\n    def __getslice__(self, start, stop):\n        key = slice(start, stop)\n        keys = self.__keys[key]\n        values = tuple(self)[key]\n        return self.__class__(zip(keys, values))\n\n    def get(self, key, default=None):\n        \"\"\" Obtain a value from the record by key, returning a default\n        value if the key does not exist.\n\n        :param key: a key\n        :param default: default value\n        :return: a value\n        \"\"\"\n        try:\n            index = self.__keys.index(str(key))\n        except ValueError:\n            return default\n        if 0 <= index < len(self):\n            return self._super_getitem_single(index)\n        else:\n            return default\n\n    def index(self, key):\n        \"\"\" Return the index of the given item.\n\n        :param key: a key\n        :return: index\n        :rtype: int\n        \"\"\"\n        if isinstance(key, int):\n            if 0 <= key < len(self.__keys):\n                return key\n            raise IndexError(key)\n        elif isinstance(key, str):\n            try:\n                return self.__keys.index(key)\n            except ValueError:\n                raise KeyError(key)\n        else:\n            raise TypeError(key)\n\n    def value(self, key=0, default=None):\n        \"\"\" Obtain a single value from the record by index or key. If no\n        index or key is specified, the first value is returned. If the\n        specified item does not exist, the default value is returned.\n\n        :param key: an index or key\n        :param default: default value\n        :return: a single value\n        \"\"\"\n        try:\n            index = self.index(key)\n        except (IndexError, KeyError):\n            return default\n        else:\n            return self[index]\n\n    def keys(self):\n        \"\"\" Return the keys of the record.\n\n        :return: list of key names\n        \"\"\"\n        return list(self.__keys)\n\n", "metadata": {"ground_truth": "    def values(self, *keys):\n        \"\"\" Return the values of the record, optionally filtering to\n        include only certain values by index or key.\n\n        :param keys: indexes or keys of the items to include; if none\n                     are provided, all values will be included\n        :return: list of values\n        :rtype: list\n        \"\"\"\n        if keys:\n            d = []\n            for key in keys:\n                try:\n                    i = self.index(key)\n                except KeyError:\n                    d.append(None)\n                else:\n                    d.append(self[i])\n            return d\n        return list(self)\n", "fpath_tuple": ["neo4j", "_data.py"], "function_name": "values", "lineno": 191, "context_start_lineno": 0, "_id": "62e60da4d76274f8a4026cf1", "task_id": "neo4j/id8"}}
{"prompt": "    def data(self, *keys):\n        \"\"\" Return the keys and values of this record as a dictionary,\n        optionally including only certain values by index or key. Keys\n        provided in the items that are not in the record will be\n        inserted with a value of :const:`None`; indexes provided\n        that are out of bounds will trigger an :exc:`IndexError`.\n\n        :param keys: indexes or keys of the items to include; if none\n                      are provided, all values will be included\n        :return: dictionary of values, keyed by field name\n        :raises: :exc:`IndexError` if an out-of-bounds index is specified\n        \"\"\"", "current_file": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom abc import (\n    ABCMeta,\n    abstractmethod,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n    Set,\n)\nfrom functools import reduce\nfrom operator import xor as xor_operator\n\nfrom ._codec.hydration import BrokenHydrationObject\nfrom ._conf import iter_items\nfrom ._meta import deprecated\nfrom .exceptions import BrokenRecordError\nfrom .graph import (\n    Node,\n    Path,\n    Relationship,\n)\n\n\nclass Record(tuple, Mapping):\n    \"\"\" A :class:`.Record` is an immutable ordered collection of key-value\n    pairs. It is generally closer to a :py:class:`namedtuple` than to a\n    :py:class:`OrderedDict` in as much as iteration of the collection will\n    yield values rather than keys.\n    \"\"\"\n\n    __keys = None\n\n    def __new__(cls, iterable=()):\n        keys = []\n        values = []\n        for key, value in iter_items(iterable):\n            keys.append(key)\n            values.append(value)\n        inst = tuple.__new__(cls, values)\n        inst.__keys = tuple(keys)\n        return inst\n\n    def _broken_record_error(self, index):\n        return BrokenRecordError(\n            f\"Record contains broken data at {index} ('{self.__keys[index]}')\"\n        )\n\n    def _super_getitem_single(self, index):\n        value = super().__getitem__(index)\n        if isinstance(value, BrokenHydrationObject):\n            raise self._broken_record_error(index) from value.error\n        return value\n\n    def __repr__(self):\n        return \"<%s %s>\" % (\n            self.__class__.__name__,\n            \" \".join(\"%s=%r\" % (field, value)\n                     for field, value in zip(self.__keys, super().__iter__()))\n        )\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __eq__(self, other):\n        \"\"\" In order to be flexible regarding comparison, the equality rules\n        for a record permit comparison with any other Sequence or Mapping.\n\n        :param other:\n        :return:\n        \"\"\"\n        compare_as_sequence = isinstance(other, Sequence)\n        compare_as_mapping = isinstance(other, Mapping)\n        if compare_as_sequence and compare_as_mapping:\n            return list(self) == list(other) and dict(self) == dict(other)\n        elif compare_as_sequence:\n            return list(self) == list(other)\n        elif compare_as_mapping:\n            return dict(self) == dict(other)\n        else:\n            return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return reduce(xor_operator, map(hash, self.items()))\n\n    def __iter__(self):\n        for i, v in enumerate(super().__iter__()):\n            if isinstance(v, BrokenHydrationObject):\n                raise self._broken_record_error(i) from v.error\n            yield v\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            keys = self.__keys[key]\n            values = super().__getitem__(key)\n            return self.__class__(zip(keys, values))\n        try:\n            index = self.index(key)\n        except IndexError:\n            return None\n        else:\n            return self._super_getitem_single(index)\n\n    # TODO: 6.0 - remove\n    @deprecated(\"This method is deprecated and will be removed in the future.\")\n    def __getslice__(self, start, stop):\n        key = slice(start, stop)\n        keys = self.__keys[key]\n        values = tuple(self)[key]\n        return self.__class__(zip(keys, values))\n\n    def get(self, key, default=None):\n        \"\"\" Obtain a value from the record by key, returning a default\n        value if the key does not exist.\n\n        :param key: a key\n        :param default: default value\n        :return: a value\n        \"\"\"\n        try:\n            index = self.__keys.index(str(key))\n        except ValueError:\n            return default\n        if 0 <= index < len(self):\n            return self._super_getitem_single(index)\n        else:\n            return default\n\n    def index(self, key):\n        \"\"\" Return the index of the given item.\n\n        :param key: a key\n        :return: index\n        :rtype: int\n        \"\"\"\n        if isinstance(key, int):\n            if 0 <= key < len(self.__keys):\n                return key\n            raise IndexError(key)\n        elif isinstance(key, str):\n            try:\n                return self.__keys.index(key)\n            except ValueError:\n                raise KeyError(key)\n        else:\n            raise TypeError(key)\n\n    def value(self, key=0, default=None):\n        \"\"\" Obtain a single value from the record by index or key. If no\n        index or key is specified, the first value is returned. If the\n        specified item does not exist, the default value is returned.\n\n        :param key: an index or key\n        :param default: default value\n        :return: a single value\n        \"\"\"\n        try:\n            index = self.index(key)\n        except (IndexError, KeyError):\n            return default\n        else:\n            return self[index]\n\n    def keys(self):\n        \"\"\" Return the keys of the record.\n\n        :return: list of key names\n        \"\"\"\n        return list(self.__keys)\n\n    def values(self, *keys):\n        \"\"\" Return the values of the record, optionally filtering to\n        include only certain values by index or key.\n\n        :param keys: indexes or keys of the items to include; if none\n                     are provided, all values will be included\n        :return: list of values\n        :rtype: list\n        \"\"\"\n        if keys:\n            d = []\n            for key in keys:\n                try:\n                    i = self.index(key)\n                except KeyError:\n                    d.append(None)\n                else:\n                    d.append(self[i])\n            return d\n        return list(self)\n\n    def items(self, *keys):\n        \"\"\" Return the fields of the record as a list of key and value tuples\n\n        :return: a list of value tuples\n        :rtype: list\n        \"\"\"\n        if keys:\n            d = []\n            for key in keys:\n                try:\n                    i = self.index(key)\n                except KeyError:\n                    d.append((key, None))\n                else:\n                    d.append((self.__keys[i], self[i]))\n            return d\n        return list((self.__keys[i], self._super_getitem_single(i))\n                    for i in range(len(self)))\n\n", "metadata": {"ground_truth": "    def data(self, *keys):\n        \"\"\" Return the keys and values of this record as a dictionary,\n        optionally including only certain values by index or key. Keys\n        provided in the items that are not in the record will be\n        inserted with a value of :const:`None`; indexes provided\n        that are out of bounds will trigger an :exc:`IndexError`.\n\n        :param keys: indexes or keys of the items to include; if none\n                      are provided, all values will be included\n        :return: dictionary of values, keyed by field name\n        :raises: :exc:`IndexError` if an out-of-bounds index is specified\n        \"\"\"\n        return RecordExporter().transform(dict(self.items(*keys)))\n", "fpath_tuple": ["neo4j", "_data.py"], "function_name": "data", "lineno": 231, "context_start_lineno": 0, "_id": "62e60b10d76274f8a4026ccd", "task_id": "neo4j/id9"}}
{"prompt": "    def pop_u16(self):\n        \"\"\" Remove the last two bytes of data, returning them as a big-endian\n        16-bit unsigned integer.\n        \"\"\"", "current_file": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom codecs import decode\nfrom contextlib import contextmanager\nfrom struct import (\n    pack as struct_pack,\n    unpack as struct_unpack,\n)\n\nfrom .._common import Structure\n\n\nPACKED_UINT_8 = [struct_pack(\">B\", value) for value in range(0x100)]\nPACKED_UINT_16 = [struct_pack(\">H\", value) for value in range(0x10000)]\n\nUNPACKED_UINT_8 = {bytes(bytearray([x])): x for x in range(0x100)}\nUNPACKED_UINT_16 = {struct_pack(\">H\", x): x for x in range(0x10000)}\n\nUNPACKED_MARKERS = {b\"\\xC0\": None, b\"\\xC2\": False, b\"\\xC3\": True}\nUNPACKED_MARKERS.update({bytes(bytearray([z])): z for z in range(0x00, 0x80)})\nUNPACKED_MARKERS.update({bytes(bytearray([z + 256])): z for z in range(-0x10, 0x00)})\n\n\nINT64_MIN = -(2 ** 63)\nINT64_MAX = 2 ** 63\n\n\nclass Packer:\n\n    def __init__(self, stream):\n        self.stream = stream\n        self._write = self.stream.write\n\n    def pack_raw(self, data):\n        self._write(data)\n\n    def pack(self, value, dehydration_hooks=None):\n        write = self._write\n\n        # None\n        if value is None:\n            write(b\"\\xC0\")  # NULL\n\n        # Boolean\n        elif value is True:\n            write(b\"\\xC3\")\n        elif value is False:\n            write(b\"\\xC2\")\n\n        # Float (only double precision is supported)\n        elif isinstance(value, float):\n            write(b\"\\xC1\")\n            write(struct_pack(\">d\", value))\n\n        # Integer\n        elif isinstance(value, int):\n            if -0x10 <= value < 0x80:\n                write(PACKED_UINT_8[value % 0x100])\n            elif -0x80 <= value < -0x10:\n                write(b\"\\xC8\")\n                write(PACKED_UINT_8[value % 0x100])\n            elif -0x8000 <= value < 0x8000:\n                write(b\"\\xC9\")\n                write(PACKED_UINT_16[value % 0x10000])\n            elif -0x80000000 <= value < 0x80000000:\n                write(b\"\\xCA\")\n                write(struct_pack(\">i\", value))\n            elif INT64_MIN <= value < INT64_MAX:\n                write(b\"\\xCB\")\n                write(struct_pack(\">q\", value))\n            else:\n                raise OverflowError(\"Integer %s out of range\" % value)\n\n        # String\n        elif isinstance(value, str):\n            encoded = value.encode(\"utf-8\")\n            self.pack_string_header(len(encoded))\n            self.pack_raw(encoded)\n\n        # Bytes\n        elif isinstance(value, (bytes, bytearray)):\n            self.pack_bytes_header(len(value))\n            self.pack_raw(value)\n\n        # List\n        elif isinstance(value, list):\n            self.pack_list_header(len(value))\n            for item in value:\n                self.pack(item, dehydration_hooks=dehydration_hooks)\n\n        # Map\n        elif isinstance(value, dict):\n            self.pack_map_header(len(value))\n            for key, item in value.items():\n                if not isinstance(key, str):\n                    raise TypeError(\n                        \"Map keys must be strings, not {}\".format(type(key))\n                    )\n                self.pack(key, dehydration_hooks=dehydration_hooks)\n                self.pack(item, dehydration_hooks=dehydration_hooks)\n\n        # Structure\n        elif isinstance(value, Structure):\n            self.pack_struct(value.tag, value.fields)\n\n        # Other\n        elif dehydration_hooks and type(value) in dehydration_hooks:\n            self.pack(dehydration_hooks[type(value)](value))\n        else:\n            raise ValueError(\"Values of type %s are not supported\" % type(value))\n\n    def pack_bytes_header(self, size):\n        write = self._write\n        if size < 0x100:\n            write(b\"\\xCC\")\n            write(PACKED_UINT_8[size])\n        elif size < 0x10000:\n            write(b\"\\xCD\")\n            write(PACKED_UINT_16[size])\n        elif size < 0x100000000:\n            write(b\"\\xCE\")\n            write(struct_pack(\">I\", size))\n        else:\n            raise OverflowError(\"Bytes header size out of range\")\n\n    def pack_string_header(self, size):\n        write = self._write\n        if size <= 0x0F:\n            write(bytes((0x80 | size,)))\n        elif size < 0x100:\n            write(b\"\\xD0\")\n            write(PACKED_UINT_8[size])\n        elif size < 0x10000:\n            write(b\"\\xD1\")\n            write(PACKED_UINT_16[size])\n        elif size < 0x100000000:\n            write(b\"\\xD2\")\n            write(struct_pack(\">I\", size))\n        else:\n            raise OverflowError(\"String header size out of range\")\n\n    def pack_list_header(self, size):\n        write = self._write\n        if size <= 0x0F:\n            write(bytes((0x90 | size,)))\n        elif size < 0x100:\n            write(b\"\\xD4\")\n            write(PACKED_UINT_8[size])\n        elif size < 0x10000:\n            write(b\"\\xD5\")\n            write(PACKED_UINT_16[size])\n        elif size < 0x100000000:\n            write(b\"\\xD6\")\n            write(struct_pack(\">I\", size))\n        else:\n            raise OverflowError(\"List header size out of range\")\n\n    def pack_map_header(self, size):\n        write = self._write\n        if size <= 0x0F:\n            write(bytes((0xA0 | size,)))\n        elif size < 0x100:\n            write(b\"\\xD8\")\n            write(PACKED_UINT_8[size])\n        elif size < 0x10000:\n            write(b\"\\xD9\")\n            write(PACKED_UINT_16[size])\n        elif size < 0x100000000:\n            write(b\"\\xDA\")\n            write(struct_pack(\">I\", size))\n        else:\n            raise OverflowError(\"Map header size out of range\")\n\n    def pack_struct(self, signature, fields, dehydration_hooks=None):\n        if len(signature) != 1 or not isinstance(signature, bytes):\n            raise ValueError(\"Structure signature must be a single byte value\")\n        write = self._write\n        size = len(fields)\n        if size <= 0x0F:\n            write(bytes((0xB0 | size,)))\n        else:\n            raise OverflowError(\"Structure size out of range\")\n        write(signature)\n        for field in fields:\n            self.pack(field, dehydration_hooks=dehydration_hooks)\n\n    @staticmethod\n    def new_packable_buffer():\n        return PackableBuffer()\n\n\nclass PackableBuffer:\n    def __init__(self):\n        self.data = bytearray()\n        # export write method for packer; \"inline\" for performance\n        self.write = self.data.extend\n        self.clear = self.data.clear\n        self._tmp_buffering = 0\n\n    @contextmanager\n    def tmp_buffer(self):\n        self._tmp_buffering += 1\n        old_len = len(self.data)\n        try:\n            yield\n        except Exception:\n            del self.data[old_len:]\n            raise\n        finally:\n            self._tmp_buffering -= 1\n\n    def is_tmp_buffering(self):\n        return bool(self._tmp_buffering)\n\n\nclass Unpacker:\n\n    def __init__(self, unpackable):\n        self.unpackable = unpackable\n\n    def reset(self):\n        self.unpackable.reset()\n\n    def read(self, n=1):\n        return self.unpackable.read(n)\n\n    def read_u8(self):\n        return self.unpackable.read_u8()\n\n    def unpack(self, hydration_hooks=None):\n        value = self._unpack(hydration_hooks=hydration_hooks)\n        if hydration_hooks and type(value) in hydration_hooks:\n            return hydration_hooks[type(value)](value)\n        return value\n\n    def _unpack(self, hydration_hooks=None):\n        marker = self.read_u8()\n\n        if marker == -1:\n            raise ValueError(\"Nothing to unpack\")\n\n        # Tiny Integer\n        if 0x00 <= marker <= 0x7F:\n            return marker\n        elif 0xF0 <= marker <= 0xFF:\n            return marker - 0x100\n\n        # Null\n        elif marker == 0xC0:\n            return None\n\n        # Float\n        elif marker == 0xC1:\n            value, = struct_unpack(\">d\", self.read(8))\n            return value\n\n        # Boolean\n        elif marker == 0xC2:\n            return False\n        elif marker == 0xC3:\n            return True\n\n        # Integer\n        elif marker == 0xC8:\n            return struct_unpack(\">b\", self.read(1))[0]\n        elif marker == 0xC9:\n            return struct_unpack(\">h\", self.read(2))[0]\n        elif marker == 0xCA:\n            return struct_unpack(\">i\", self.read(4))[0]\n        elif marker == 0xCB:\n            return struct_unpack(\">q\", self.read(8))[0]\n\n        # Bytes\n        elif marker == 0xCC:\n            size, = struct_unpack(\">B\", self.read(1))\n            return self.read(size).tobytes()\n        elif marker == 0xCD:\n            size, = struct_unpack(\">H\", self.read(2))\n            return self.read(size).tobytes()\n        elif marker == 0xCE:\n            size, = struct_unpack(\">I\", self.read(4))\n            return self.read(size).tobytes()\n\n        else:\n            marker_high = marker & 0xF0\n            # String\n            if marker_high == 0x80:  # TINY_STRING\n                return decode(self.read(marker & 0x0F), \"utf-8\")\n            elif marker == 0xD0:  # STRING_8:\n                size, = struct_unpack(\">B\", self.read(1))\n                return decode(self.read(size), \"utf-8\")\n            elif marker == 0xD1:  # STRING_16:\n                size, = struct_unpack(\">H\", self.read(2))\n                return decode(self.read(size), \"utf-8\")\n            elif marker == 0xD2:  # STRING_32:\n                size, = struct_unpack(\">I\", self.read(4))\n                return decode(self.read(size), \"utf-8\")\n\n            # List\n            elif 0x90 <= marker <= 0x9F or 0xD4 <= marker <= 0xD6:\n                return list(self._unpack_list_items(\n                    marker, hydration_hooks=hydration_hooks)\n                )\n\n            # Map\n            elif 0xA0 <= marker <= 0xAF or 0xD8 <= marker <= 0xDA:\n                return self._unpack_map(\n                    marker, hydration_hooks=hydration_hooks\n                )\n\n            # Structure\n            elif 0xB0 <= marker <= 0xBF:\n                size, tag = self._unpack_structure_header(marker)\n                value = Structure(tag, *([None] * size))\n                for i in range(len(value)):\n                    value[i] = self.unpack(hydration_hooks=hydration_hooks)\n                return value\n\n            else:\n                raise ValueError(\"Unknown PackStream marker %02X\" % marker)\n\n    def _unpack_list_items(self, marker, hydration_hooks=None):\n        marker_high = marker & 0xF0\n        if marker_high == 0x90:\n            size = marker & 0x0F\n            if size == 0:\n                return\n            elif size == 1:\n                yield self.unpack(hydration_hooks=hydration_hooks)\n            else:\n                for _ in range(size):\n                    yield self.unpack(hydration_hooks=hydration_hooks)\n        elif marker == 0xD4:  # LIST_8:\n            size, = struct_unpack(\">B\", self.read(1))\n            for _ in range(size):\n                yield self.unpack(hydration_hooks=hydration_hooks)\n        elif marker == 0xD5:  # LIST_16:\n            size, = struct_unpack(\">H\", self.read(2))\n            for _ in range(size):\n                yield self.unpack(hydration_hooks=hydration_hooks)\n        elif marker == 0xD6:  # LIST_32:\n            size, = struct_unpack(\">I\", self.read(4))\n            for _ in range(size):\n                yield self.unpack(hydration_hooks=hydration_hooks)\n        else:\n            return\n\n    def unpack_map(self, hydration_hooks=None):\n        marker = self.read_u8()\n        return self._unpack_map(marker, hydration_hooks=hydration_hooks)\n\n    def _unpack_map(self, marker, hydration_hooks=None):\n        marker_high = marker & 0xF0\n        if marker_high == 0xA0:\n            size = marker & 0x0F\n            value = {}\n            for _ in range(size):\n                key = self.unpack(hydration_hooks=hydration_hooks)\n                value[key] = self.unpack(hydration_hooks=hydration_hooks)\n            return value\n        elif marker == 0xD8:  # MAP_8:\n            size, = struct_unpack(\">B\", self.read(1))\n            value = {}\n            for _ in range(size):\n                key = self.unpack(hydration_hooks=hydration_hooks)\n                value[key] = self.unpack(hydration_hooks=hydration_hooks)\n            return value\n        elif marker == 0xD9:  # MAP_16:\n            size, = struct_unpack(\">H\", self.read(2))\n            value = {}\n            for _ in range(size):\n                key = self.unpack(hydration_hooks=hydration_hooks)\n                value[key] = self.unpack(hydration_hooks=hydration_hooks)\n            return value\n        elif marker == 0xDA:  # MAP_32:\n            size, = struct_unpack(\">I\", self.read(4))\n            value = {}\n            for _ in range(size):\n                key = self.unpack(hydration_hooks=hydration_hooks)\n                value[key] = self.unpack(hydration_hooks=hydration_hooks)\n            return value\n        else:\n            return None\n\n    def unpack_structure_header(self):\n        marker = self.read_u8()\n        if marker == -1:\n            return None, None\n        else:\n            return self._unpack_structure_header(marker)\n\n    def _unpack_structure_header(self, marker):\n        marker_high = marker & 0xF0\n        if marker_high == 0xB0:  # TINY_STRUCT\n            signature = self.read(1).tobytes()\n            return marker & 0x0F, signature\n        else:\n            raise ValueError(\"Expected structure, found marker %02X\" % marker)\n\n    @staticmethod\n    def new_unpackable_buffer():\n        return UnpackableBuffer()\n\n\nclass UnpackableBuffer:\n\n    initial_capacity = 8192\n\n    def __init__(self, data=None):\n        if data is None:\n            self.data = bytearray(self.initial_capacity)\n            self.used = 0\n        else:\n            self.data = bytearray(data)\n            self.used = len(self.data)\n        self.p = 0\n\n    def reset(self):\n        self.used = 0\n        self.p = 0\n\n    def read(self, n=1):\n        view = memoryview(self.data)\n        q = self.p + n\n        subview = view[self.p:q]\n        self.p = q\n        return subview\n\n    def read_u8(self):\n        if self.used - self.p >= 1:\n            value = self.data[self.p]\n            self.p += 1\n            return value\n        else:\n            return -1\n\n", "metadata": {"ground_truth": "    def pop_u16(self):\n        \"\"\" Remove the last two bytes of data, returning them as a big-endian\n        16-bit unsigned integer.\n        \"\"\"\n        if self.used >= 2:\n            value = 0x100 * self.data[self.used - 2] + self.data[self.used - 1]\n            self.used -= 2\n            return value\n        else:\n            return -1\n", "fpath_tuple": ["neo4j", "_codec", "packstream", "v1", "__init__.py"], "function_name": "pop_u16", "lineno": 453, "context_start_lineno": 0, "_id": "62e6087bd76274f8a4026bfa", "task_id": "neo4j/id10"}}
{"prompt": "    def discard(self, n=-1, qid=-1, dehydration_hooks=None,\n                hydration_hooks=None, **handlers):\n        # Just ignore n and qid, it is not supported in the Bolt 3 Protocol.\n        log.debug(\"[#%04X]  C: DISCARD_ALL\", self.local_port)\n        self._append(b\"\\x2F\", (),\n                     Response(self, \"discard\", hydration_hooks, **handlers),\n                     dehydration_hooks=dehydration_hooks)\n\"\"\"", "current_file": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom enum import Enum\nfrom logging import getLogger\nfrom ssl import SSLSocket\n\nfrom ..._async_compat.util import AsyncUtil\nfrom ..._exceptions import (\n    BoltError,\n    BoltProtocolError,\n)\nfrom ...api import (\n    READ_ACCESS,\n    Version,\n)\nfrom ...exceptions import (\n    ConfigurationError,\n    DatabaseUnavailable,\n    DriverError,\n    ForbiddenOnReadOnlyDatabase,\n    Neo4jError,\n    NotALeader,\n    ServiceUnavailable,\n)\nfrom ._bolt import AsyncBolt\nfrom ._common import (\n    check_supported_server_product,\n    CommitResponse,\n    InitResponse,\n    Response,\n)\n\n\nlog = getLogger(\"neo4j\")\n\n\nclass ServerStates(Enum):\n    CONNECTED = \"CONNECTED\"\n    READY = \"READY\"\n    STREAMING = \"STREAMING\"\n    TX_READY_OR_TX_STREAMING = \"TX_READY||TX_STREAMING\"\n    FAILED = \"FAILED\"\n\n\nclass ServerStateManager:\n    _STATE_TRANSITIONS = {\n        ServerStates.CONNECTED: {\n            \"hello\": ServerStates.READY,\n        },\n        ServerStates.READY: {\n            \"run\": ServerStates.STREAMING,\n            \"begin\": ServerStates.TX_READY_OR_TX_STREAMING,\n        },\n        ServerStates.STREAMING: {\n            \"pull\": ServerStates.READY,\n            \"discard\": ServerStates.READY,\n            \"reset\": ServerStates.READY,\n        },\n        ServerStates.TX_READY_OR_TX_STREAMING: {\n            \"commit\": ServerStates.READY,\n            \"rollback\": ServerStates.READY,\n            \"reset\": ServerStates.READY,\n        },\n        ServerStates.FAILED: {\n            \"reset\": ServerStates.READY,\n        }\n    }\n\n    def __init__(self, init_state, on_change=None):\n        self.state = init_state\n        self._on_change = on_change\n\n    def transition(self, message, metadata):\n        if metadata.get(\"has_more\"):\n            return\n        state_before = self.state\n        self.state = self._STATE_TRANSITIONS\\\n            .get(self.state, {})\\\n            .get(message, self.state)\n        if state_before != self.state and callable(self._on_change):\n            self._on_change(state_before, self.state)\n\n\nclass AsyncBolt3(AsyncBolt):\n    \"\"\" Protocol handler for Bolt 3.\n\n    This is supported by Neo4j versions 3.5, 4.0, 4.1, 4.2, 4.3, and 4.4.\n    \"\"\"\n\n    PROTOCOL_VERSION = Version(3, 0)\n\n    supports_multiple_results = False\n\n    supports_multiple_databases = False\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._server_state_manager = ServerStateManager(\n            ServerStates.CONNECTED, on_change=self._on_server_state_change\n        )\n\n    def _on_server_state_change(self, old_state, new_state):\n        log.debug(\"[#%04X]  State: %s > %s\", self.local_port,\n                  old_state.name, new_state.name)\n\n    @property\n    def is_reset(self):\n        # We can't be sure of the server's state if there are still pending\n        # responses. Unless the last message we sent was RESET. In that case\n        # the server state will always be READY when we're done.\n        if (self.responses and self.responses[-1]\n                and self.responses[-1].message == \"reset\"):\n            return True\n        return self._server_state_manager.state == ServerStates.READY\n\n    @property\n    def encrypted(self):\n        return isinstance(self.socket, SSLSocket)\n\n    @property\n    def der_encoded_server_certificate(self):\n        return self.socket.getpeercert(binary_form=True)\n\n    def get_base_headers(self):\n        return {\n            \"user_agent\": self.user_agent,\n        }\n\n    async def hello(self, dehydration_hooks=None, hydration_hooks=None):\n        headers = self.get_base_headers()\n        headers.update(self.auth_dict)\n        logged_headers = dict(headers)\n        if \"credentials\" in logged_headers:\n            logged_headers[\"credentials\"] = \"*******\"\n        log.debug(\"[#%04X]  C: HELLO %r\", self.local_port, logged_headers)\n        self._append(b\"\\x01\", (headers,),\n                     response=InitResponse(self, \"hello\", hydration_hooks,\n                                           on_success=self.server_info.update),\n                     dehydration_hooks=dehydration_hooks)\n        await self.send_all()\n        await self.fetch_all()\n        check_supported_server_product(self.server_info.agent)\n\n    async def route(\n        self, database=None, imp_user=None, bookmarks=None,\n        dehydration_hooks=None, hydration_hooks=None\n    ):\n        if database is not None:\n            raise ConfigurationError(\n                \"Database name parameter for selecting database is not \"\n                \"supported in Bolt Protocol {!r}. Database name {!r}. \"\n                \"Server Agent {!r}\".format(\n                    self.PROTOCOL_VERSION, database, self.server_info.agent\n                )\n            )\n        if imp_user is not None:\n            raise ConfigurationError(\n                \"Impersonation is not supported in Bolt Protocol {!r}. \"\n                \"Trying to impersonate {!r}.\".format(\n                    self.PROTOCOL_VERSION, imp_user\n                )\n            )\n\n        metadata = {}\n        records = []\n\n        # Ignoring database and bookmarks because there is no multi-db support.\n        # The bookmarks are only relevant for making sure a previously created\n        # db exists before querying a routing table for it.\n        self.run(\n            \"CALL dbms.cluster.routing.getRoutingTable($context)\",  # This is an internal procedure call. Only available if the Neo4j 3.5 is setup with clustering.\n            {\"context\": self.routing_context},\n            mode=\"r\",                                               # Bolt Protocol Version(3, 0) supports mode=\"r\"\n            dehydration_hooks=dehydration_hooks,\n            hydration_hooks=hydration_hooks,\n            on_success=metadata.update\n        )\n        self.pull(dehydration_hooks = None, hydration_hooks = None,\n                  on_success=metadata.update, on_records=records.extend)\n        await self.send_all()\n        await self.fetch_all()\n        routing_info = [dict(zip(metadata.get(\"fields\", ()), values)) for values in records]\n        return routing_info\n\n    def run(self, query, parameters=None, mode=None, bookmarks=None,\n            metadata=None, timeout=None, db=None, imp_user=None,\n            dehydration_hooks=None, hydration_hooks=None, **handlers):\n        if db is not None:\n            raise ConfigurationError(\n                \"Database name parameter for selecting database is not \"\n                \"supported in Bolt Protocol {!r}. Database name {!r}.\".format(\n                    self.PROTOCOL_VERSION, db\n                )\n            )\n        if imp_user is not None:\n            raise ConfigurationError(\n                \"Impersonation is not supported in Bolt Protocol {!r}. \"\n                \"Trying to impersonate {!r}.\".format(\n                    self.PROTOCOL_VERSION, imp_user\n                )\n            )\n        if not parameters:\n            parameters = {}\n        extra = {}\n        if mode in (READ_ACCESS, \"r\"):\n            extra[\"mode\"] = \"r\"  # It will default to mode \"w\" if nothing is specified\n        if bookmarks:\n            try:\n                extra[\"bookmarks\"] = list(bookmarks)\n            except TypeError:\n                raise TypeError(\"Bookmarks must be provided within an iterable\")\n        if metadata:\n            try:\n                extra[\"tx_metadata\"] = dict(metadata)\n            except TypeError:\n                raise TypeError(\"Metadata must be coercible to a dict\")\n        if timeout is not None:\n            try:\n                extra[\"tx_timeout\"] = int(1000 * float(timeout))\n            except TypeError:\n                raise TypeError(\"Timeout must be specified as a number of seconds\")\n            if extra[\"tx_timeout\"] < 0:\n                raise ValueError(\"Timeout must be a positive number or 0.\")\n        fields = (query, parameters, extra)\n        log.debug(\"[#%04X]  C: RUN %s\", self.local_port, \" \".join(map(repr, fields)))\n        self._append(b\"\\x10\", fields,\n                     Response(self, \"run\", hydration_hooks, **handlers),\n                     dehydration_hooks=dehydration_hooks)\n\n", "metadata": {"ground_truth": "    def discard(self, n=-1, qid=-1, dehydration_hooks=None,\n                hydration_hooks=None, **handlers):\n        # Just ignore n and qid, it is not supported in the Bolt 3 Protocol.\n        log.debug(\"[#%04X]  C: DISCARD_ALL\", self.local_port)\n        self._append(b\"\\x2F\", (),\n                     Response(self, \"discard\", hydration_hooks, **handlers),\n                     dehydration_hooks=dehydration_hooks)\n", "fpath_tuple": ["neo4j", "_async", "io", "_bolt3.py"], "function_name": "discard", "lineno": 246, "context_start_lineno": 0, "_id": "62e6087ad76274f8a4026bf2", "task_id": "neo4j/id11"}}
{"prompt": "    def begin(self, mode=None, bookmarks=None, metadata=None, timeout=None,\n              db=None, imp_user=None, dehydration_hooks=None,\n              hydration_hooks=None, **handlers):\n        if db is not None:\n            raise ConfigurationError(\n                \"Database name parameter for selecting database is not \"\n                \"supported in Bolt Protocol {!r}. Database name {!r}.\".format(\n                    self.PROTOCOL_VERSION, db\n                )\n            )\n        if imp_user is not None:\n            raise ConfigurationError(\n                \"Impersonation is not supported in Bolt Protocol {!r}. \"\n                \"Trying to impersonate {!r}.\".format(\n                    self.PROTOCOL_VERSION, imp_user\n                )\n            )\n        extra = {}\n        if mode in (READ_ACCESS, \"r\"):\n            extra[\"mode\"] = \"r\"  # It will default to mode \"w\" if nothing is specified\n        if bookmarks:\n            try:\n                extra[\"bookmarks\"] = list(bookmarks)\n            except TypeError:\n                raise TypeError(\"Bookmarks must be provided within an iterable\")\n        if metadata:\n            try:\n                extra[\"tx_metadata\"] = dict(metadata)\n            except TypeError:\n                raise TypeError(\"Metadata must be coercible to a dict\")\n        if timeout is not None:\n            try:\n                extra[\"tx_timeout\"] = int(1000 * float(timeout))\n            except TypeError:\n                raise TypeError(\"Timeout must be specified as a number of seconds\")\n            if extra[\"tx_timeout\"] < 0:\n                raise ValueError(\"Timeout must be a positive number or 0.\")\n        log.debug(\"[#%04X]  C: BEGIN %r\", self.local_port, extra)\n        self._append(b\"\\x11\", (extra,),\n                     Response(self, \"begin\", hydration_hooks, **handlers),\n                     dehydration_hooks=dehydration_hooks)\n\"\"\"", "current_file": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom enum import Enum\nfrom logging import getLogger\nfrom ssl import SSLSocket\n\nfrom ..._async_compat.util import AsyncUtil\nfrom ..._exceptions import (\n    BoltError,\n    BoltProtocolError,\n)\nfrom ...api import (\n    READ_ACCESS,\n    Version,\n)\nfrom ...exceptions import (\n    ConfigurationError,\n    DatabaseUnavailable,\n    DriverError,\n    ForbiddenOnReadOnlyDatabase,\n    Neo4jError,\n    NotALeader,\n    ServiceUnavailable,\n)\nfrom ._bolt import AsyncBolt\nfrom ._common import (\n    check_supported_server_product,\n    CommitResponse,\n    InitResponse,\n    Response,\n)\n\n\nlog = getLogger(\"neo4j\")\n\n\nclass ServerStates(Enum):\n    CONNECTED = \"CONNECTED\"\n    READY = \"READY\"\n    STREAMING = \"STREAMING\"\n    TX_READY_OR_TX_STREAMING = \"TX_READY||TX_STREAMING\"\n    FAILED = \"FAILED\"\n\n\nclass ServerStateManager:\n    _STATE_TRANSITIONS = {\n        ServerStates.CONNECTED: {\n            \"hello\": ServerStates.READY,\n        },\n        ServerStates.READY: {\n            \"run\": ServerStates.STREAMING,\n            \"begin\": ServerStates.TX_READY_OR_TX_STREAMING,\n        },\n        ServerStates.STREAMING: {\n            \"pull\": ServerStates.READY,\n            \"discard\": ServerStates.READY,\n            \"reset\": ServerStates.READY,\n        },\n        ServerStates.TX_READY_OR_TX_STREAMING: {\n            \"commit\": ServerStates.READY,\n            \"rollback\": ServerStates.READY,\n            \"reset\": ServerStates.READY,\n        },\n        ServerStates.FAILED: {\n            \"reset\": ServerStates.READY,\n        }\n    }\n\n    def __init__(self, init_state, on_change=None):\n        self.state = init_state\n        self._on_change = on_change\n\n    def transition(self, message, metadata):\n        if metadata.get(\"has_more\"):\n            return\n        state_before = self.state\n        self.state = self._STATE_TRANSITIONS\\\n            .get(self.state, {})\\\n            .get(message, self.state)\n        if state_before != self.state and callable(self._on_change):\n            self._on_change(state_before, self.state)\n\n\nclass AsyncBolt3(AsyncBolt):\n    \"\"\" Protocol handler for Bolt 3.\n\n    This is supported by Neo4j versions 3.5, 4.0, 4.1, 4.2, 4.3, and 4.4.\n    \"\"\"\n\n    PROTOCOL_VERSION = Version(3, 0)\n\n    supports_multiple_results = False\n\n    supports_multiple_databases = False\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._server_state_manager = ServerStateManager(\n            ServerStates.CONNECTED, on_change=self._on_server_state_change\n        )\n\n    def _on_server_state_change(self, old_state, new_state):\n        log.debug(\"[#%04X]  State: %s > %s\", self.local_port,\n                  old_state.name, new_state.name)\n\n    @property\n    def is_reset(self):\n        # We can't be sure of the server's state if there are still pending\n        # responses. Unless the last message we sent was RESET. In that case\n        # the server state will always be READY when we're done.\n        if (self.responses and self.responses[-1]\n                and self.responses[-1].message == \"reset\"):\n            return True\n        return self._server_state_manager.state == ServerStates.READY\n\n    @property\n    def encrypted(self):\n        return isinstance(self.socket, SSLSocket)\n\n    @property\n    def der_encoded_server_certificate(self):\n        return self.socket.getpeercert(binary_form=True)\n\n    def get_base_headers(self):\n        return {\n            \"user_agent\": self.user_agent,\n        }\n\n    async def hello(self, dehydration_hooks=None, hydration_hooks=None):\n        headers = self.get_base_headers()\n        headers.update(self.auth_dict)\n        logged_headers = dict(headers)\n        if \"credentials\" in logged_headers:\n            logged_headers[\"credentials\"] = \"*******\"\n        log.debug(\"[#%04X]  C: HELLO %r\", self.local_port, logged_headers)\n        self._append(b\"\\x01\", (headers,),\n                     response=InitResponse(self, \"hello\", hydration_hooks,\n                                           on_success=self.server_info.update),\n                     dehydration_hooks=dehydration_hooks)\n        await self.send_all()\n        await self.fetch_all()\n        check_supported_server_product(self.server_info.agent)\n\n    async def route(\n        self, database=None, imp_user=None, bookmarks=None,\n        dehydration_hooks=None, hydration_hooks=None\n    ):\n        if database is not None:\n            raise ConfigurationError(\n                \"Database name parameter for selecting database is not \"\n                \"supported in Bolt Protocol {!r}. Database name {!r}. \"\n                \"Server Agent {!r}\".format(\n                    self.PROTOCOL_VERSION, database, self.server_info.agent\n                )\n            )\n        if imp_user is not None:\n            raise ConfigurationError(\n                \"Impersonation is not supported in Bolt Protocol {!r}. \"\n                \"Trying to impersonate {!r}.\".format(\n                    self.PROTOCOL_VERSION, imp_user\n                )\n            )\n\n        metadata = {}\n        records = []\n\n        # Ignoring database and bookmarks because there is no multi-db support.\n        # The bookmarks are only relevant for making sure a previously created\n        # db exists before querying a routing table for it.\n        self.run(\n            \"CALL dbms.cluster.routing.getRoutingTable($context)\",  # This is an internal procedure call. Only available if the Neo4j 3.5 is setup with clustering.\n            {\"context\": self.routing_context},\n            mode=\"r\",                                               # Bolt Protocol Version(3, 0) supports mode=\"r\"\n            dehydration_hooks=dehydration_hooks,\n            hydration_hooks=hydration_hooks,\n            on_success=metadata.update\n        )\n        self.pull(dehydration_hooks = None, hydration_hooks = None,\n                  on_success=metadata.update, on_records=records.extend)\n        await self.send_all()\n        await self.fetch_all()\n        routing_info = [dict(zip(metadata.get(\"fields\", ()), values)) for values in records]\n        return routing_info\n\n    def run(self, query, parameters=None, mode=None, bookmarks=None,\n            metadata=None, timeout=None, db=None, imp_user=None,\n            dehydration_hooks=None, hydration_hooks=None, **handlers):\n        if db is not None:\n            raise ConfigurationError(\n                \"Database name parameter for selecting database is not \"\n                \"supported in Bolt Protocol {!r}. Database name {!r}.\".format(\n                    self.PROTOCOL_VERSION, db\n                )\n            )\n        if imp_user is not None:\n            raise ConfigurationError(\n                \"Impersonation is not supported in Bolt Protocol {!r}. \"\n                \"Trying to impersonate {!r}.\".format(\n                    self.PROTOCOL_VERSION, imp_user\n                )\n            )\n        if not parameters:\n            parameters = {}\n        extra = {}\n        if mode in (READ_ACCESS, \"r\"):\n            extra[\"mode\"] = \"r\"  # It will default to mode \"w\" if nothing is specified\n        if bookmarks:\n            try:\n                extra[\"bookmarks\"] = list(bookmarks)\n            except TypeError:\n                raise TypeError(\"Bookmarks must be provided within an iterable\")\n        if metadata:\n            try:\n                extra[\"tx_metadata\"] = dict(metadata)\n            except TypeError:\n                raise TypeError(\"Metadata must be coercible to a dict\")\n        if timeout is not None:\n            try:\n                extra[\"tx_timeout\"] = int(1000 * float(timeout))\n            except TypeError:\n                raise TypeError(\"Timeout must be specified as a number of seconds\")\n            if extra[\"tx_timeout\"] < 0:\n                raise ValueError(\"Timeout must be a positive number or 0.\")\n        fields = (query, parameters, extra)\n        log.debug(\"[#%04X]  C: RUN %s\", self.local_port, \" \".join(map(repr, fields)))\n        self._append(b\"\\x10\", fields,\n                     Response(self, \"run\", hydration_hooks, **handlers),\n                     dehydration_hooks=dehydration_hooks)\n\n    def discard(self, n=-1, qid=-1, dehydration_hooks=None,\n                hydration_hooks=None, **handlers):\n        # Just ignore n and qid, it is not supported in the Bolt 3 Protocol.\n        log.debug(\"[#%04X]  C: DISCARD_ALL\", self.local_port)\n        self._append(b\"\\x2F\", (),\n                     Response(self, \"discard\", hydration_hooks, **handlers),\n                     dehydration_hooks=dehydration_hooks)\n\n    def pull(self, n=-1, qid=-1, dehydration_hooks=None, hydration_hooks=None,\n             **handlers):\n        # Just ignore n and qid, it is not supported in the Bolt 3 Protocol.\n        log.debug(\"[#%04X]  C: PULL_ALL\", self.local_port)\n        self._append(b\"\\x3F\", (),\n                     Response(self, \"pull\", hydration_hooks, **handlers),\n                     dehydration_hooks=dehydration_hooks)\n\n", "metadata": {"ground_truth": "    def begin(self, mode=None, bookmarks=None, metadata=None, timeout=None,\n              db=None, imp_user=None, dehydration_hooks=None,\n              hydration_hooks=None, **handlers):\n        if db is not None:\n            raise ConfigurationError(\n                \"Database name parameter for selecting database is not \"\n                \"supported in Bolt Protocol {!r}. Database name {!r}.\".format(\n                    self.PROTOCOL_VERSION, db\n                )\n            )\n        if imp_user is not None:\n            raise ConfigurationError(\n                \"Impersonation is not supported in Bolt Protocol {!r}. \"\n                \"Trying to impersonate {!r}.\".format(\n                    self.PROTOCOL_VERSION, imp_user\n                )\n            )\n        extra = {}\n        if mode in (READ_ACCESS, \"r\"):\n            extra[\"mode\"] = \"r\"  # It will default to mode \"w\" if nothing is specified\n        if bookmarks:\n            try:\n                extra[\"bookmarks\"] = list(bookmarks)\n            except TypeError:\n                raise TypeError(\"Bookmarks must be provided within an iterable\")\n        if metadata:\n            try:\n                extra[\"tx_metadata\"] = dict(metadata)\n            except TypeError:\n                raise TypeError(\"Metadata must be coercible to a dict\")\n        if timeout is not None:\n            try:\n                extra[\"tx_timeout\"] = int(1000 * float(timeout))\n            except TypeError:\n                raise TypeError(\"Timeout must be specified as a number of seconds\")\n            if extra[\"tx_timeout\"] < 0:\n                raise ValueError(\"Timeout must be a positive number or 0.\")\n        log.debug(\"[#%04X]  C: BEGIN %r\", self.local_port, extra)\n        self._append(b\"\\x11\", (extra,),\n                     Response(self, \"begin\", hydration_hooks, **handlers),\n                     dehydration_hooks=dehydration_hooks)\n", "fpath_tuple": ["neo4j", "_async", "io", "_bolt3.py"], "function_name": "begin", "lineno": 262, "context_start_lineno": 0, "_id": "62e60879d76274f8a4026bec", "task_id": "neo4j/id12"}}
{"prompt": "def round_half_to_even(n):\n    \"\"\"\n\n        >>> round_half_to_even(3)\n        3\n        >>> round_half_to_even(3.2)\n        3\n        >>> round_half_to_even(3.5)\n        4\n        >>> round_half_to_even(3.7)\n        4\n        >>> round_half_to_even(4)\n        4\n        >>> round_half_to_even(4.2)\n        4\n        >>> round_half_to_even(4.5)\n        4\n        >>> round_half_to_even(4.7)\n        5\n\n    :param n:\n    :return:\n    \"\"\"", "current_file": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\n__all__ = [\n    \"nano_add\",\n    \"nano_div\",\n    \"nano_divmod\",\n    \"symmetric_divmod\",\n    \"round_half_to_even\",\n]\n\n\ndef nano_add(x, y):\n    \"\"\"\n\n        >>> 0.7 + 0.2\n        0.8999999999999999\n        >>> -0.7 + 0.2\n        -0.49999999999999994\n        >>> nano_add(0.7, 0.2)\n        0.9\n        >>> nano_add(-0.7, 0.2)\n        -0.5\n\n    :param x:\n    :param y:\n    :return:\n    \"\"\"\n    return (int(1000000000 * x) + int(1000000000 * y)) / 1000000000\n\n\ndef nano_div(x, y):\n    \"\"\"\n\n        >>> 0.7 / 0.2\n        3.4999999999999996\n        >>> -0.7 / 0.2\n        -3.4999999999999996\n        >>> nano_div(0.7, 0.2)\n        3.5\n        >>> nano_div(-0.7, 0.2)\n        -3.5\n\n    :param x:\n    :param y:\n    :return:\n    \"\"\"\n    return float(1000000000 * x) / int(1000000000 * y)\n\n\ndef nano_divmod(x, y):\n    \"\"\"\n\n        >>> divmod(0.7, 0.2)\n        (3.0, 0.09999999999999992)\n        >>> nano_divmod(0.7, 0.2)\n        (3, 0.1)\n\n    :param x:\n    :param y:\n    :return:\n    \"\"\"\n    number = type(x)\n    nx = int(1000000000 * x)\n    ny = int(1000000000 * y)\n    q, r = divmod(nx, ny)\n    return int(q), number(r / 1000000000)\n\n\ndef symmetric_divmod(dividend, divisor):\n    number = type(dividend)\n    if dividend >= 0:\n        quotient, remainder = divmod(dividend, divisor)\n        return int(quotient), number(remainder)\n    else:\n        quotient, remainder = divmod(-dividend, divisor)\n        return -int(quotient), -number(remainder)\n\n\n", "metadata": {"ground_truth": "def round_half_to_even(n):\n    \"\"\"\n\n        >>> round_half_to_even(3)\n        3\n        >>> round_half_to_even(3.2)\n        3\n        >>> round_half_to_even(3.5)\n        4\n        >>> round_half_to_even(3.7)\n        4\n        >>> round_half_to_even(4)\n        4\n        >>> round_half_to_even(4.2)\n        4\n        >>> round_half_to_even(4.5)\n        4\n        >>> round_half_to_even(4.7)\n        5\n\n    :param n:\n    :return:\n    \"\"\"\n    ten_n = 10 * n\n    if ten_n == int(ten_n) and ten_n % 10 == 5:\n        up = int(n + 0.5)\n        down = int(n - 0.5)\n        return up if up % 2 == 0 else down\n    else:\n        return int(round(n))\n", "fpath_tuple": ["neo4j", "time", "_arithmetic.py"], "function_name": "round_half_to_even", "lineno": 95, "context_start_lineno": 0, "_id": "62e60723d76274f8a4026b75", "task_id": "neo4j/id13"}}
{"prompt": "def point_type(name, fields, srid_map):\n    \"\"\" Dynamically create a Point subclass.\n    \"\"\"", "current_file": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\n\"\"\"\nThis module defines _spatial data types.\n\"\"\"\n\n\nfrom threading import Lock\n\n\n# SRID to subclass mappings\nsrid_table = {}\nsrid_table_lock = Lock()\n\n\nclass Point(tuple):\n    \"\"\"Base-class for _spatial data.\n\n    A point within a geometric space. This type is generally used via its\n    subclasses and should not be instantiated directly unless there is no\n    subclass defined for the required SRID.\n\n    :param iterable:\n        An iterable of coordinates.\n        All items will be converted to :class:`float`.\n    \"\"\"\n\n    #: The SRID (_spatial reference identifier) of the _spatial data.\n    #: A number that identifies the coordinate system the _spatial type is to be\n    #: interpreted in.\n    #:\n    #: :type: int\n    srid = None\n\n    def __new__(cls, iterable):\n        return tuple.__new__(cls, map(float, iterable))\n\n    def __repr__(self):\n        return \"POINT(%s)\" % \" \".join(map(str, self))\n\n    def __eq__(self, other):\n        try:\n            return type(self) is type(other) and tuple(self) == tuple(other)\n        except (AttributeError, TypeError):\n            return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash(type(self)) ^ hash(tuple(self))\n\n\n", "metadata": {"ground_truth": "def point_type(name, fields, srid_map):\n    \"\"\" Dynamically create a Point subclass.\n    \"\"\"\n\n    def srid(self):\n        try:\n            return srid_map[len(self)]\n        except KeyError:\n            return None\n\n    attributes = {\"srid\": property(srid)}\n\n    for index, subclass_field in enumerate(fields):\n\n        def accessor(self, i=index, f=subclass_field):\n            try:\n                return self[i]\n            except IndexError:\n                raise AttributeError(f)\n\n        for field_alias in {subclass_field, \"xyz\"[index]}:\n            attributes[field_alias] = property(accessor)\n\n    cls = type(name, (Point,), attributes)\n\n    with srid_table_lock:\n        for dim, srid in srid_map.items():\n            srid_table[srid] = (cls, dim)\n\n    return cls\n", "fpath_tuple": ["neo4j", "_spatial", "__init__.py"], "function_name": "point_type", "lineno": 70, "context_start_lineno": 0, "_id": "62e60707d76274f8a4026b69", "task_id": "neo4j/id14"}}
{"prompt": "def deprecated(message):\n    \"\"\" Decorator for deprecating functions and methods.\n\n    ::\n\n        @deprecated(\"'foo' has been deprecated in favour of 'bar'\")\n        def foo(x):\n            pass\n\n    \"\"\"", "current_file": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport asyncio\nfrom functools import wraps\nfrom warnings import warn\n\n\n# Can be automatically overridden in builds\npackage = \"neo4j\"\nversion = \"5.0.dev0\"\n\n\ndef get_user_agent():\n    \"\"\" Obtain the default user agent string sent to the server after\n    a successful handshake.\n    \"\"\"\n    from sys import (\n        platform,\n        version_info,\n    )\n    template = \"neo4j-python/{} Python/{}.{}.{}-{}-{} ({})\"\n    fields = (version,) + tuple(version_info) + (platform,)\n    return template.format(*fields)\n\n\ndef deprecation_warn(message, stack_level=1):\n    warn(message, category=DeprecationWarning, stacklevel=stack_level + 1)\n\n\n", "metadata": {"ground_truth": "def deprecated(message):\n    \"\"\" Decorator for deprecating functions and methods.\n\n    ::\n\n        @deprecated(\"'foo' has been deprecated in favour of 'bar'\")\n        def foo(x):\n            pass\n\n    \"\"\"\n    def decorator(f):\n        if asyncio.iscoroutinefunction(f):\n            @wraps(f)\n            async def inner(*args, **kwargs):\n                deprecation_warn(message, stack_level=2)\n                return await f(*args, **kwargs)\n\n            return inner\n        else:\n            @wraps(f)\n            def inner(*args, **kwargs):\n                deprecation_warn(message, stack_level=2)\n                return f(*args, **kwargs)\n\n            return inner\n\n    return decorator\n", "fpath_tuple": ["neo4j", "_meta.py"], "function_name": "deprecated", "lineno": 46, "context_start_lineno": 0, "_id": "62e5dc9ed76274f8a4026b5b", "task_id": "neo4j/id15"}}
{"prompt": "    @classmethod\n    def from_ticks(cls, ticks, tz=None):\n        \"\"\"Create a time from ticks (nanoseconds since midnight).\n\n        :param ticks: nanoseconds since midnight\n        :type ticks: int\n        :param tz: optional timezone\n        :type tz: datetime.tzinfo\n\n        :rtype: Time\n\n        :raises ValueError: if ticks is out of bounds\n            (0 <= ticks < 86400000000000)\n        \"\"\"", "current_file": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\n\"\"\"\nThis module contains the fundamental types used for temporal accounting as well\nas a number of utility functions.\n\"\"\"\n\n\nfrom datetime import (\n    date,\n    datetime,\n    time,\n    timedelta,\n    timezone,\n)\nfrom functools import total_ordering\nfrom re import compile as re_compile\nfrom time import (\n    gmtime,\n    mktime,\n    struct_time,\n)\n\nfrom ._arithmetic import (\n    nano_add,\n    nano_div,\n    round_half_to_even,\n    symmetric_divmod,\n)\nfrom ._metaclasses import (\n    DateTimeType,\n    DateType,\n    TimeType,\n)\n\n\n__all__ = [\n    \"MIN_INT64\",\n    \"MAX_INT64\",\n    \"MIN_YEAR\",\n    \"MAX_YEAR\",\n    \"Duration\",\n    \"Date\",\n    \"ZeroDate\",\n    \"Time\",\n    \"Midnight\",\n    \"Midday\",\n    \"DateTime\",\n    \"Never\",\n    \"UnixEpoch\",\n]\n\n\nMIN_INT64 = -(2 ** 63)\nMAX_INT64 = (2 ** 63) - 1\n\n#: The smallest year number allowed in a :class:`.Date` or :class:`.DateTime`\n#: object to be compatible with :class:`datetime.date` and\n#: :class:`datetime.datetime`.\nMIN_YEAR = 1\n\n#: The largest year number allowed in a :class:`.Date` or :class:`.DateTime`\n#: object to be compatible with :class:`datetime.date` and\n#: :class:`datetime.datetime`.\nMAX_YEAR = 9999\n\nDATE_ISO_PATTERN = re_compile(r\"^(\\d{4})-(\\d{2})-(\\d{2})$\")\nTIME_ISO_PATTERN = re_compile(\n    r\"^(\\d{2})(:(\\d{2})(:((\\d{2})\"\n    r\"(\\.\\d*)?))?)?(([+-])(\\d{2}):(\\d{2})(:((\\d{2})(\\.\\d*)?))?)?$\"\n)\nDURATION_ISO_PATTERN = re_compile(\n    r\"^P((\\d+)Y)?((\\d+)M)?((\\d+)D)?\"\n    r\"(T((\\d+)H)?((\\d+)M)?(((\\d+)(\\.\\d+)?)?S)?)?$\"\n)\n\nNANO_SECONDS = 1000000000\nAVERAGE_SECONDS_IN_MONTH = 2629746\nAVERAGE_SECONDS_IN_DAY = 86400\n\n\ndef _is_leap_year(year):\n    if year % 4 != 0:\n        return False\n    if year % 100 != 0:\n        return True\n    return year % 400 == 0\n\n\nIS_LEAP_YEAR = {year: _is_leap_year(year) for year in range(MIN_YEAR, MAX_YEAR + 1)}\n\n\ndef _days_in_year(year):\n    return 366 if IS_LEAP_YEAR[year] else 365\n\n\nDAYS_IN_YEAR = {year: _days_in_year(year) for year in range(MIN_YEAR, MAX_YEAR + 1)}\n\n\ndef _days_in_month(year, month):\n    if month in (9, 4, 6, 11):\n        return 30\n    elif month != 2:\n        return 31\n    else:\n        return 29 if IS_LEAP_YEAR[year] else 28\n\n\nDAYS_IN_MONTH = {(year, month): _days_in_month(year, month)\n                 for year in range(MIN_YEAR, MAX_YEAR + 1) for month in range(1, 13)}\n\n\ndef _normalize_day(year, month, day):\n    \"\"\" Coerce the day of the month to an internal value that may or\n    may not match the \"public\" value.\n\n    With the exception of the last three days of every month, all\n    days are stored as-is. The last three days are instead stored\n    as -1 (the last), -2 (the second to last) and -3 (the third to\n    last).\n\n    Therefore, for a 28-day month, the last week is as follows:\n\n        Day   | 22 23 24 25 26 27 28\n        Value | 22 23 24 25 -3 -2 -1\n\n    For a 29-day month, the last week is as follows:\n\n        Day   | 23 24 25 26 27 28 29\n        Value | 23 24 25 26 -3 -2 -1\n\n    For a 30-day month, the last week is as follows:\n\n        Day   | 24 25 26 27 28 29 30\n        Value | 24 25 26 27 -3 -2 -1\n\n    For a 31-day month, the last week is as follows:\n\n        Day   | 25 26 27 28 29 30 31\n        Value | 25 26 27 28 -3 -2 -1\n\n    This slightly unintuitive system makes some temporal arithmetic\n    produce a more desirable outcome.\n\n    :param year:\n    :param month:\n    :param day:\n    :return:\n    \"\"\"\n    if year < MIN_YEAR or year > MAX_YEAR:\n        raise ValueError(\"Year out of range (%d..%d)\" % (MIN_YEAR, MAX_YEAR))\n    if month < 1 or month > 12:\n        raise ValueError(\"Month out of range (1..12)\")\n    days_in_month = DAYS_IN_MONTH[(year, month)]\n    if day in (days_in_month, -1):\n        return year, month, -1\n    if day in (days_in_month - 1, -2):\n        return year, month, -2\n    if day in (days_in_month - 2, -3):\n        return year, month, -3\n    if 1 <= day <= days_in_month - 3:\n        return year, month, int(day)\n    # TODO improve this error message\n    raise ValueError(\"Day %d out of range (1..%d, -1, -2 ,-3)\" % (day, days_in_month))\n\n\nclass ClockTime(tuple):\n    \"\"\" A count of `seconds` and `nanoseconds`. This class can be used to\n    mark a particular point in time, relative to an externally-specified\n    epoch.\n\n    The `seconds` and `nanoseconds` values provided to the constructor can\n    can have any sign but will be normalized internally into a positive or\n    negative `seconds` value along with a positive `nanoseconds` value\n    between `0` and `999,999,999`. Therefore ``ClockTime(-1, -1)`` is\n    normalized to ``ClockTime(-2, 999999999)``.\n\n    Note that the structure of a :class:`.ClockTime` object is similar to\n    the ``timespec`` struct in C.\n    \"\"\"\n\n    def __new__(cls, seconds=0, nanoseconds=0):\n        seconds, nanoseconds = divmod(\n            int(NANO_SECONDS * seconds) + int(nanoseconds), NANO_SECONDS\n        )\n        return tuple.__new__(cls, (seconds, nanoseconds))\n\n    def __add__(self, other):\n        if isinstance(other, (int, float)):\n            other = ClockTime(other)\n        if isinstance(other, ClockTime):\n            return ClockTime(self.seconds + other.seconds, self.nanoseconds + other.nanoseconds)\n        if isinstance(other, Duration):\n            if other.months or other.days:\n                raise ValueError(\"Cannot add Duration with months or days\")\n            return ClockTime(self.seconds + other.seconds, self.nanoseconds +\n                             int(other.nanoseconds))\n        return NotImplemented\n\n    def __sub__(self, other):\n        if isinstance(other, (int, float)):\n            other = ClockTime(other)\n        if isinstance(other, ClockTime):\n            return ClockTime(self.seconds - other.seconds, self.nanoseconds - other.nanoseconds)\n        if isinstance(other, Duration):\n            if other.months or other.days:\n                raise ValueError(\"Cannot subtract Duration with months or days\")\n            return ClockTime(self.seconds - other.seconds, self.nanoseconds - int(other.nanoseconds))\n        return NotImplemented\n\n    def __repr__(self):\n        return \"ClockTime(seconds=%r, nanoseconds=%r)\" % self\n\n    @property\n    def seconds(self):\n        return self[0]\n\n    @property\n    def nanoseconds(self):\n        return self[1]\n\n\nclass Clock:\n    \"\"\" Accessor for time values. This class is fulfilled by implementations\n    that subclass :class:`.Clock`. These implementations are contained within\n    the ``neo4j.time.clock_implementations`` module, and are not intended to be\n    accessed directly.\n\n    Creating a new :class:`.Clock` instance will produce the highest\n    precision clock implementation available.\n\n        >>> clock = Clock()\n        >>> type(clock)                                         # doctest: +SKIP\n        neo4j.time.clock_implementations.LibCClock\n        >>> clock.local_time()                                  # doctest: +SKIP\n        ClockTime(seconds=1525265942, nanoseconds=506844026)\n\n    \"\"\"\n\n    __implementations = None\n\n    def __new__(cls):\n        if cls.__implementations is None:\n            # Find an available clock with the best precision\n            import neo4j.time._clock_implementations\n            cls.__implementations = sorted((clock for clock in Clock.__subclasses__() if clock.available()),\n                                           key=lambda clock: clock.precision(), reverse=True)\n        if not cls.__implementations:\n            raise RuntimeError(\"No clock implementations available\")\n        instance = object.__new__(cls.__implementations[0])\n        return instance\n\n    @classmethod\n    def precision(cls):\n        \"\"\" The precision of this clock implementation, represented as a\n        number of decimal places. Therefore, for a nanosecond precision\n        clock, this function returns `9`.\n        \"\"\"\n        raise NotImplementedError(\"No clock implementation selected\")\n\n    @classmethod\n    def available(cls):\n        \"\"\" A boolean flag to indicate whether or not this clock\n        implementation is available on this platform.\n        \"\"\"\n        raise NotImplementedError(\"No clock implementation selected\")\n\n    @classmethod\n    def local_offset(cls):\n        \"\"\"The offset from UTC for local time read from this clock.\n        This may raise OverflowError if not supported, because of platform depending C libraries.\n\n        :returns:\n        :rtype:\n\n        :raises OverflowError:\n        \"\"\"\n        # Adding and subtracting two days to avoid passing a pre-epoch time to\n        # `mktime`, which can cause a `OverflowError` on some platforms (e.g.,\n        # Windows).\n        return ClockTime(-int(mktime(gmtime(172800))) + 172800)\n\n    def local_time(self):\n        \"\"\" Read and return the current local time from this clock, measured relative to the Unix Epoch.\n        This may raise OverflowError if not supported, because of platform depending C libraries.\n\n        :returns:\n        :rtype:\n\n        :raises OverflowError:\n        \"\"\"\n        return self.utc_time() + self.local_offset()\n\n    def utc_time(self):\n        \"\"\" Read and return the current UTC time from this clock, measured\n        relative to the Unix Epoch.\n        \"\"\"\n        raise NotImplementedError(\"No clock implementation selected\")\n\n\nclass Duration(tuple):\n    \"\"\"A difference between two points in time.\n\n    A :class:`.Duration` represents the difference between two points in time.\n    Duration objects store a composite value of `months`, `days`, `seconds`,\n    and `nanoseconds`. Unlike :class:`datetime.timedelta` however, days, and\n    seconds/nanoseconds are never interchanged. All values except seconds and\n    nanoseconds are applied separately in calculations (element-wise).\n\n    A :class:`.Duration` stores four primary instance attributes internally:\n    `months`, `days`, `seconds` and `nanoseconds`. These are maintained as\n    individual values and are immutable. Each of these four attributes can carry\n    its own sign, with the exception of `nanoseconds`, which always has the same\n    sign as `seconds`. The constructor will establish this state, should the\n    duration be initialized with conflicting `seconds` and `nanoseconds` signs.\n    This structure allows the modelling of durations such as\n    `3 months minus 2 days`.\n\n    To determine if a :class:`Duration` `d` is overflowing the accepted values\n    of the database, first, all `nanoseconds` outside the range -999_999_999 and\n    999_999_999 are transferred into the seconds field. Then, `months`, `days`,\n    and `seconds` are summed up like so:\n    `months * 2629746 + days * 86400 + d.seconds + d.nanoseconds // 1000000000`.\n    (Like the integer division in Python, this one is to be understood as\n    rounding down rather than towards 0.)\n    This value must be between -(2\\\\ :sup:`63`) and (2\\\\ :sup:`63` - 1)\n    inclusive.\n\n    :param years: will be added times 12 to `months`\n    :type years: float\n    :param months: will be truncated to :class:`int` (`int(months)`)\n    :type months: float\n    :param weeks: will be added times 7 to `days`\n    :type weeks: float\n    :param days: will be truncated to :class:`int` (`int(days)`)\n    :type days: float\n    :param hours: will be added times 3,600,000,000,000 to `nanoseconds`\n    :type hours: float\n    :param minutes: will be added times 60,000,000,000 to `nanoseconds`\n    :type minutes: float\n    :param seconds: will be added times 1,000,000,000 to `nanoseconds``\n    :type seconds: float\n    :param milliseconds: will be added times 1,000,000 to `nanoseconds`\n    :type microseconds: float\n    :param microseconds: will be added times 1,000 to `nanoseconds`\n    :type milliseconds: float\n    :param nanoseconds: will be truncated to :class:`int` (`int(nanoseconds)`)\n    :type nanoseconds: float\n\n    :raises ValueError: the components exceed the limits as described above.\n    \"\"\"\n\n    # i64: i64:i64: i32\n\n    min = None\n    \"\"\"The lowest duration value possible.\"\"\"\n\n    max = None\n    \"\"\"The highest duration value possible.\"\"\"\n\n    def __new__(cls, years=0, months=0, weeks=0, days=0, hours=0, minutes=0,\n                seconds=0, milliseconds=0, microseconds=0, nanoseconds=0):\n        mo = int(12 * years + months)\n        if mo < MIN_INT64 or mo > MAX_INT64:\n            raise ValueError(\"Months value out of range\")\n        d = int(7 * weeks + days)\n        ns = (int(3600000000000 * hours) +\n              int(60000000000 * minutes) +\n              int(1000000000 * seconds) +\n              int(1000000 * milliseconds) +\n              int(1000 * microseconds) +\n              int(nanoseconds))\n        s, ns = symmetric_divmod(ns, NANO_SECONDS)\n        avg_total_seconds = (mo * AVERAGE_SECONDS_IN_MONTH\n                             + d * AVERAGE_SECONDS_IN_DAY\n                             + s\n                             - (1 if ns < 0 else 0))\n        if avg_total_seconds < MIN_INT64 or avg_total_seconds > MAX_INT64:\n            raise ValueError(\"Duration value out of range: %r\",\n                             cls.__repr__((mo, d, s, ns)))\n        return tuple.__new__(cls, (mo, d, s, ns))\n\n    def __bool__(self):\n        \"\"\"Falsy if all primary instance attributes are.\"\"\"\n        return any(map(bool, self))\n\n    __nonzero__ = __bool__\n\n    def __add__(self, other):\n        \"\"\"Add a :class:`.Duration` or :class:`datetime.timedelta`.\n\n        :rtype: Duration\n        \"\"\"\n        if isinstance(other, Duration):\n            return Duration(\n                months=self[0] + int(other.months),\n                days=self[1] + int(other.days),\n                seconds=self[2] + int(other.seconds),\n                nanoseconds=self[3] + int(other.nanoseconds)\n            )\n        if isinstance(other, timedelta):\n            return Duration(\n                months=self[0], days=self[1] + other.days,\n                seconds=self[2] + other.seconds,\n                nanoseconds=self[3] + other.microseconds * 1000\n            )\n        return NotImplemented\n\n    def __sub__(self, other):\n        \"\"\"Subtract a :class:`.Duration` or :class:`datetime.timedelta`.\n\n        :rtype: Duration\n        \"\"\"\n        if isinstance(other, Duration):\n            return Duration(\n                months=self[0] - int(other.months),\n                days=self[1] - int(other.days),\n                seconds=self[2] - int(other.seconds),\n                nanoseconds=self[3] - int(other.nanoseconds)\n            )\n        if isinstance(other, timedelta):\n            return Duration(\n                months=self[0],\n                days=self[1] - other.days,\n                seconds=self[2] - other.seconds,\n                nanoseconds=self[3] - other.microseconds * 1000\n            )\n        return NotImplemented\n\n    def __mul__(self, other):\n        \"\"\"Multiply by an :class:`int` or :class:`float`.\n\n        The operation is performed element-wise on\n        ``(months, days, nanaoseconds)`` where\n\n        * years go into months,\n        * weeks go into days,\n        * seconds and all sub-second units go into nanoseconds.\n\n        Each element will be rounded to the nearest integer (.5 towards even).\n\n        :rtype: Duration\n        \"\"\"\n        if isinstance(other, (int, float)):\n            return Duration(\n                months=round_half_to_even(self[0] * other),\n                days=round_half_to_even(self[1] * other),\n                nanoseconds=round_half_to_even(\n                    self[2] * NANO_SECONDS * other\n                    + self[3] * other\n                )\n            )\n        return NotImplemented\n\n    def __floordiv__(self, other):\n        \"\"\"Integer division by an :class:`int`.\n\n        The operation is performed element-wise on\n        ``(months, days, nanaoseconds)`` where\n\n        * years go into months,\n        * weeks go into days,\n        * seconds and all sub-second units go into nanoseconds.\n\n        Each element will be rounded towards -inf.\n\n        :rtype: Duration\n        \"\"\"\n        if isinstance(other, int):\n            return Duration(\n                months=self[0] // other, days=self[1] // other,\n                nanoseconds=(self[2] * NANO_SECONDS + self[3]) // other\n            )\n        return NotImplemented\n\n    def __mod__(self, other):\n        \"\"\"Modulo operation by an :class:`int`.\n\n        The operation is performed element-wise on\n        ``(months, days, nanaoseconds)`` where\n\n        * years go into months,\n        * weeks go into days,\n        * seconds and all sub-second units go into nanoseconds.\n\n        :rtype: Duration\n        \"\"\"\n        if isinstance(other, int):\n            return Duration(\n                months=self[0] % other, days=self[1] % other,\n                nanoseconds=(self[2] * NANO_SECONDS + self[3]) % other\n            )\n        return NotImplemented\n\n    def __divmod__(self, other):\n        \"\"\"Division and modulo operation by an :class:`int`.\n\n        See :meth:`__floordiv__` and :meth:`__mod__`.\n\n        :rtype: (Duration, Duration)\n        \"\"\"\n        if isinstance(other, int):\n            return self.__floordiv__(other), self.__mod__(other)\n        return NotImplemented\n\n    def __truediv__(self, other):\n        \"\"\"Division by an :class:`int` or :class:`float`.\n\n        The operation is performed element-wise on\n        ``(months, days, nanaoseconds)`` where\n\n        * years go into months,\n        * weeks go into days,\n        * seconds and all sub-second units go into nanoseconds.\n\n        Each element will be rounded to the nearest integer (.5 towards even).\n\n        :rtype: Duration\n        \"\"\"\n        if isinstance(other, (int, float)):\n            return Duration(\n                months=round_half_to_even(self[0] / other),\n                days=round_half_to_even(self[1] / other),\n                nanoseconds=round_half_to_even(\n                    self[2] * NANO_SECONDS / other\n                    + self[3] / other\n                )\n            )\n        return NotImplemented\n\n    def __pos__(self):\n        \"\"\"\"\"\"\n        return self\n\n    def __neg__(self):\n        \"\"\"\"\"\"\n        return Duration(months=-self[0], days=-self[1], seconds=-self[2],\n                        nanoseconds=-self[3])\n\n    def __abs__(self):\n        \"\"\"\"\"\"\n        return Duration(months=abs(self[0]), days=abs(self[1]),\n                        seconds=abs(self[2]), nanoseconds=abs(self[3]))\n\n    def __repr__(self):\n        \"\"\"\"\"\"\n        return \"Duration(months=%r, days=%r, seconds=%r, nanoseconds=%r)\" % self\n\n    def __str__(self):\n        \"\"\"\"\"\"\n        return self.iso_format()\n\n    def __copy__(self):\n        return self.__new__(self.__class__, months=self[0], days=self[1],\n                            seconds=self[2], nanoseconds=self[3])\n\n    def __deepcopy__(self, memodict={}):\n        return self.__copy__()\n\n    @classmethod\n    def from_iso_format(cls, s):\n        \"\"\"Parse a ISO formatted duration string.\n\n        Accepted formats (all lowercase letters are placeholders):\n            'P', a zero length duration\n            'PyY', y being a number of years\n            'PmM', m being a number of months\n            'PdD', d being a number of days\n\n            Any combination of the above, e.g., 'P25Y1D' for 25 years and 1 day.\n\n            'PThH', h being a number of hours\n            'PTmM', h being a number of minutes\n            'PTsS', h being a number of seconds\n            'PTs.sss...S', h being a fractional number of seconds\n\n            Any combination of the above, e.g. 'PT5H1.2S' for 5 hours and 1.2\n            seconds.\n            Any combination of all options, e.g. 'P13MT100M' for 13 months and\n            100 minutes.\n\n        :param s: String to parse\n        :type s: str\n\n        :rtype: Duration\n\n        :raises ValueError: if the string does not match the required format.\n        \"\"\"\n        match = DURATION_ISO_PATTERN.match(s)\n        if match:\n            ns = 0\n            if match.group(15):\n                ns = int(match.group(15)[1:10].ljust(9, \"0\"))\n            return cls(\n                years=int(match.group(2) or 0),\n                months=int(match.group(4) or 0),\n                days=int(match.group(6) or 0),\n                hours=int(match.group(9) or 0),\n                minutes=int(match.group(11) or 0),\n                seconds=int(match.group(14) or 0),\n                nanoseconds=ns\n            )\n        raise ValueError(\"Duration string must be in ISO format\")\n\n    fromisoformat = from_iso_format\n\n    def iso_format(self, sep=\"T\"):\n        \"\"\"Return the :class:`Duration` as ISO formatted string.\n\n        :param sep: the separator before the time components.\n        :type sep: str\n\n        :rtype: str\n        \"\"\"\n        parts = []\n        hours, minutes, seconds, nanoseconds = \\\n            self.hours_minutes_seconds_nanoseconds\n        if hours:\n            parts.append(\"%dH\" % hours)\n        if minutes:\n            parts.append(\"%dM\" % minutes)\n        if nanoseconds:\n            if seconds >= 0 and nanoseconds >= 0:\n                parts.append(\"%d.%sS\" %\n                             (seconds,\n                              str(nanoseconds).rjust(9, \"0\").rstrip(\"0\")))\n            elif seconds <= 0 and nanoseconds <= 0:\n                parts.append(\"-%d.%sS\" %\n                             (abs(seconds),\n                              str(abs(nanoseconds)).rjust(9, \"0\").rstrip(\"0\")))\n\n            else:\n                assert False and \"Please report this issue\"\n        elif seconds:\n            parts.append(\"%dS\" % seconds)\n        if parts:\n            parts.insert(0, sep)\n        years, months, days = self.years_months_days\n        if days:\n            parts.insert(0, \"%dD\" % days)\n        if months:\n            parts.insert(0, \"%dM\" % months)\n        if years:\n            parts.insert(0, \"%dY\" % years)\n        if parts:\n            parts.insert(0, \"P\")\n            return \"\".join(parts)\n        else:\n            return \"PT0S\"\n\n    @property\n    def months(self):\n        \"\"\"The months of the :class:`Duration`.\n\n        :type: int\n        \"\"\"\n        return self[0]\n\n    @property\n    def days(self):\n        \"\"\"The days of the :class:`Duration`.\n\n        :type: int\n        \"\"\"\n        return self[1]\n\n    @property\n    def seconds(self):\n        \"\"\"The seconds of the :class:`Duration`.\n\n        :type: int\n        \"\"\"\n        return self[2]\n\n    @property\n    def nanoseconds(self):\n        \"\"\"The nanoseconds of the :class:`Duration`.\n\n        :type: int\n        \"\"\"\n        return self[3]\n\n    @property\n    def years_months_days(self):\n        \"\"\"\n\n        :return:\n        \"\"\"\n        years, months = symmetric_divmod(self[0], 12)\n        return years, months, self[1]\n\n    @property\n    def hours_minutes_seconds_nanoseconds(self):\n        \"\"\" A 4-tuple of (hours, minutes, seconds, nanoseconds).\n\n        :type: (int, int, int, int)\n        \"\"\"\n        minutes, seconds = symmetric_divmod(self[2], 60)\n        hours, minutes = symmetric_divmod(minutes, 60)\n        return hours, minutes, seconds, self[3]\n\n\nDuration.min = Duration(seconds=MIN_INT64, nanoseconds=0)\nDuration.max = Duration(seconds=MAX_INT64, nanoseconds=999999999)\n\n\nclass Date(metaclass=DateType):\n    \"\"\"Idealized date representation.\n\n    A :class:`.Date` object represents a date (year, month, and day) in the\n    `proleptic Gregorian Calendar\n    <https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar>`_.\n\n    Years between `0001` and `9999` are supported, with additional support for\n    the \"zero date\" used in some contexts.\n\n    Each date is based on a proleptic Gregorian ordinal, which models\n    1 Jan 0001 as `day 1` and counts each subsequent day up to, and including,\n    31 Dec 9999. The standard `year`, `month` and `day` value of each date is\n    also available.\n\n    Internally, the day of the month is always stored as-is, with the exception\n    of the last three days of that month. These are always stored as\n    -1, -2 and -3 (counting from the last day). This system allows some temporal\n    arithmetic (particularly adding or subtracting months) to produce a more\n    desirable outcome than would otherwise be produced. Externally, the day\n    number is always the same as would be written on a calendar.\n\n    :param year: the year. Minimum :attr:`.MIN_YEAR` (0001), maximum\n        :attr:`.MAX_YEAR` (9999).\n    :type year: int\n    :param month: the month. Minimum 1, maximum 12.\n    :type month: int\n    :param day: the day. Minimum 1, maximum\n        :attr:`Date.days_in_month(year, month) <Date.days_in_month>`.\n    :type day: int\n\n    A zero date can also be acquired by passing all zeroes to the\n    :class:`neo4j.time.Date` constructor or by using the :attr:`ZeroDate`\n    constant.\n    \"\"\"\n\n    # CONSTRUCTOR #\n\n    def __new__(cls, year, month, day):\n        if year == month == day == 0:\n            return ZeroDate\n        year, month, day = _normalize_day(year, month, day)\n        ordinal = cls.__calc_ordinal(year, month, day)\n        return cls.__new(ordinal, year, month, day)\n\n    @classmethod\n    def __new(cls, ordinal, year, month, day):\n        instance = object.__new__(cls)\n        instance.__ordinal = int(ordinal)\n        instance.__year = int(year)\n        instance.__month = int(month)\n        instance.__day = int(day)\n        return instance\n\n    def __getattr__(self, name):\n        \"\"\" Map standard library attribute names to local attribute names,\n        for compatibility.\n        \"\"\"\n        try:\n            return {\n                \"isocalendar\": self.iso_calendar,\n                \"isoformat\": self.iso_format,\n                \"isoweekday\": self.iso_weekday,\n                \"strftime\": self.__format__,\n                \"toordinal\": self.to_ordinal,\n                \"timetuple\": self.time_tuple,\n            }[name]\n        except KeyError:\n            raise AttributeError(\"Date has no attribute %r\" % name)\n\n    # CLASS METHODS #\n\n    @classmethod\n    def today(cls, tz=None):\n        \"\"\"Get the current date.\n\n        :param tz: timezone or None to get the local :class:`.Date`.\n        :type tz: datetime.tzinfo or None\n\n        :rtype: Date\n\n        :raises OverflowError: if the timestamp is out of the range of values\n            supported by the platform C localtime() function. It’s common for\n            this to be restricted to years from 1970 through 2038.\n        \"\"\"\n        if tz is None:\n            return cls.from_clock_time(Clock().local_time(), UnixEpoch)\n        else:\n            return (\n                DateTime.utc_now()\n                .replace(tzinfo=timezone.utc).astimezone(tz)\n                .date()\n            )\n\n    @classmethod\n    def utc_today(cls):\n        \"\"\"Get the current date as UTC local date.\n\n        :rtype: Date\n        \"\"\"\n        return cls.from_clock_time(Clock().utc_time(), UnixEpoch)\n\n    @classmethod\n    def from_timestamp(cls, timestamp, tz=None):\n        \"\"\":class:`.Date` from a time stamp (seconds since unix epoch).\n\n        :param timestamp: the unix timestamp (seconds since unix epoch).\n        :type timestamp: float\n        :param tz: timezone. Set to None to create a local :class:`.Date`.\n        :type tz: datetime.tzinfo or None\n\n        :rtype: Date\n\n        :raises OverflowError: if the timestamp is out of the range of values\n            supported by the platform C localtime() function. It’s common for\n            this to be restricted to years from 1970 through 2038.\n        \"\"\"\n        return cls.from_native(datetime.fromtimestamp(timestamp, tz))\n\n    @classmethod\n    def utc_from_timestamp(cls, timestamp):\n        \"\"\":class:`.Date` from a time stamp (seconds since unix epoch).\n\n        Returns the `Date` as local date `Date` in UTC.\n\n        :rtype: Date\n        \"\"\"\n        return cls.from_clock_time((timestamp, 0), UnixEpoch)\n\n    @classmethod\n    def from_ordinal(cls, ordinal):\n        \"\"\"\n        The :class:`.Date` that corresponds to the proleptic Gregorian ordinal.\n\n        `0001-01-01` has ordinal 1 and `9999-12-31` has ordinal 3,652,059.\n        Values outside of this range trigger a :exc:`ValueError`.\n        The corresponding instance method for the reverse date-to-ordinal\n        transformation is :meth:`.to_ordinal`.\n        The ordinal 0 has a special semantic and will return :attr:`ZeroDate`.\n\n        :rtype: Date\n\n        :raises ValueError: if the ordinal is outside the range [0, 3652059]\n            (both values included).\n        \"\"\"\n        if ordinal == 0:\n            return ZeroDate\n        if ordinal >= 736695:\n            year = 2018     # Project release year\n            month = 1\n            day = int(ordinal - 736694)\n        elif ordinal >= 719163:\n            year = 1970     # Unix epoch\n            month = 1\n            day = int(ordinal - 719162)\n        else:\n            year = 1\n            month = 1\n            day = int(ordinal)\n        if day < 1 or day > 3652059:\n            # Note: this requires a maximum of 22 bits for storage\n            # Could be transferred in 3 bytes.\n            raise ValueError(\"Ordinal out of range (1..3652059)\")\n        if year < MIN_YEAR or year > MAX_YEAR:\n            raise ValueError(\"Year out of range (%d..%d)\" % (MIN_YEAR, MAX_YEAR))\n        days_in_year = DAYS_IN_YEAR[year]\n        while day > days_in_year:\n            day -= days_in_year\n            year += 1\n            days_in_year = DAYS_IN_YEAR[year]\n        days_in_month = DAYS_IN_MONTH[(year, month)]\n        while day > days_in_month:\n            day -= days_in_month\n            month += 1\n            days_in_month = DAYS_IN_MONTH[(year, month)]\n        year, month, day = _normalize_day(year, month, day)\n        return cls.__new(ordinal, year, month, day)\n\n    @classmethod\n    def parse(cls, s):\n        \"\"\"Parse a string to produce a :class:`.Date`.\n\n        Accepted formats:\n            'Y-M-D'\n\n        :param s: the string to be parsed.\n        :type s: str\n\n        :rtype: Date\n\n        :raises ValueError: if the string could not be parsed.\n        \"\"\"\n        try:\n            numbers = map(int, s.split(\"-\"))\n        except (ValueError, AttributeError):\n            raise ValueError(\"Date string must be in format YYYY-MM-DD\")\n        else:\n            numbers = list(numbers)\n            if len(numbers) == 3:\n                return cls(*numbers)\n            raise ValueError(\"Date string must be in format YYYY-MM-DD\")\n\n    @classmethod\n    def from_iso_format(cls, s):\n        \"\"\"Parse a ISO formatted Date string.\n\n        Accepted formats:\n            'YYYY-MM-DD'\n\n        :param s: the string to be parsed.\n        :type s: str\n\n        :rtype: Date\n\n        :raises ValueError: if the string could not be parsed.\n        \"\"\"\n        m = DATE_ISO_PATTERN.match(s)\n        if m:\n            year = int(m.group(1))\n            month = int(m.group(2))\n            day = int(m.group(3))\n            return cls(year, month, day)\n        raise ValueError(\"Date string must be in format YYYY-MM-DD\")\n\n    @classmethod\n    def from_native(cls, d):\n        \"\"\"Convert from a native Python `datetime.date` value.\n\n        :param d: the date to convert.\n        :type d: datetime.date\n\n        :rtype: Date\n        \"\"\"\n        return Date.from_ordinal(d.toordinal())\n\n    @classmethod\n    def from_clock_time(cls, clock_time, epoch):\n        \"\"\"Convert from a ClockTime relative to a given epoch.\n\n        :param clock_time: the clock time as :class:`.ClockTime` or as tuple of\n            (seconds, nanoseconds)\n        :type clock_time: ClockTime or (float, int)\n        :param epoch: the epoch to which `clock_time` is relative\n        :type epoch: DateTime\n\n        :rtype: Date\n        \"\"\"\n        try:\n            clock_time = ClockTime(*clock_time)\n        except (TypeError, ValueError):\n            raise ValueError(\"Clock time must be a 2-tuple of (s, ns)\")\n        else:\n            ordinal = clock_time.seconds // 86400\n            return Date.from_ordinal(ordinal + epoch.date().to_ordinal())\n\n    @classmethod\n    def is_leap_year(cls, year):\n        \"\"\"Indicates whether or not `year` is a leap year.\n\n        :param year: the year to look up\n        :type year: int\n\n        :rtype: bool\n\n        :raises ValueError: if `year` is out of range:\n            :attr:`MIN_YEAR` <= year <= :attr:`MAX_YEAR`\n        \"\"\"\n        if year < MIN_YEAR or year > MAX_YEAR:\n            raise ValueError(\"Year out of range (%d..%d)\" % (MIN_YEAR, MAX_YEAR))\n        return IS_LEAP_YEAR[year]\n\n    @classmethod\n    def days_in_year(cls, year):\n        \"\"\"Return the number of days in `year`.\n\n        :param year: the year to look up\n        :type year: int\n\n        :rtype: int\n\n        :raises ValueError: if `year` is out of range:\n            :attr:`MIN_YEAR` <= year <= :attr:`MAX_YEAR`\n        \"\"\"\n        if year < MIN_YEAR or year > MAX_YEAR:\n            raise ValueError(\"Year out of range (%d..%d)\" % (MIN_YEAR, MAX_YEAR))\n        return DAYS_IN_YEAR[year]\n\n    @classmethod\n    def days_in_month(cls, year, month):\n        \"\"\"Return the number of days in `month` of `year`.\n\n        :param year: the year to look up\n        :type year: int\n        :param year: the month to look up\n        :type year: int\n\n        :rtype: int\n\n        :raises ValueError: if `year` or `month` is out of range:\n            :attr:`MIN_YEAR` <= year <= :attr:`MAX_YEAR`;\n            1 <= year <= 12\n        \"\"\"\n        if year < MIN_YEAR or year > MAX_YEAR:\n            raise ValueError(\"Year out of range (%d..%d)\" % (MIN_YEAR, MAX_YEAR))\n        if month < 1 or month > 12:\n            raise ValueError(\"Month out of range (1..12)\")\n        return DAYS_IN_MONTH[(year, month)]\n\n    @classmethod\n    def __calc_ordinal(cls, year, month, day):\n        if day < 0:\n            day = cls.days_in_month(year, month) + int(day) + 1\n        # The built-in date class does this faster than a\n        # long-hand pure Python algorithm could\n        return date(year, month, day).toordinal()\n\n    # CLASS ATTRIBUTES #\n\n    min = None\n    \"\"\"The earliest date value possible.\"\"\"\n\n    max = None\n    \"\"\"The latest date value possible.\"\"\"\n\n    resolution = None\n    \"\"\"The minimum resolution supported.\"\"\"\n\n    # INSTANCE ATTRIBUTES #\n\n    __ordinal = 0\n\n    __year = 0\n\n    __month = 0\n\n    __day = 0\n\n    @property\n    def year(self):\n        \"\"\"The year of the date.\n\n        :type: int\n        \"\"\"\n        return self.__year\n\n    @property\n    def month(self):\n        \"\"\"The month of the date.\n\n        :type: int\n        \"\"\"\n        return self.__month\n\n    @property\n    def day(self):\n        \"\"\"The day of the date.\n\n        :type: int\n        \"\"\"\n        if self.__day == 0:\n            return 0\n        if self.__day >= 1:\n            return self.__day\n        return self.days_in_month(self.__year, self.__month) + self.__day + 1\n\n    @property\n    def year_month_day(self):\n        \"\"\"3-tuple of (year, month, day) describing the date.\n\n        :rtype: (int, int, int)\n        \"\"\"\n        return self.year, self.month, self.day\n\n    @property\n    def year_week_day(self):\n        \"\"\"3-tuple of (year, week_of_year, day_of_week) describing the date.\n\n        `day_of_week` will be 1 for Monday and 7 for Sunday.\n\n        :rtype: (int, int, int)\n        \"\"\"\n        ordinal = self.__ordinal\n        year = self.__year\n\n        def day_of_week(o):\n            return ((o - 1) % 7) + 1\n\n        def iso_week_1(y):\n            j4 = Date(y, 1, 4)\n            return j4 + Duration(days=(1 - day_of_week(j4.to_ordinal())))\n\n        if ordinal >= Date(year, 12, 29).to_ordinal():\n            week1 = iso_week_1(year + 1)\n            if ordinal < week1.to_ordinal():\n                week1 = iso_week_1(year)\n            else:\n                year += 1\n        else:\n            week1 = iso_week_1(year)\n            if ordinal < week1.to_ordinal():\n                year -= 1\n                week1 = iso_week_1(year)\n        return (year, int((ordinal - week1.to_ordinal()) / 7 + 1),\n                day_of_week(ordinal))\n\n    @property\n    def year_day(self):\n        \"\"\"2-tuple of (year, day_of_the_year) describing the date.\n\n        This is the number of the day relative to the start of the year,\n        with `1 Jan` corresponding to `1`.\n\n        :rtype: (int, int)\n        \"\"\"\n        return (self.__year,\n                self.toordinal() - Date(self.__year, 1, 1).toordinal() + 1)\n\n    # OPERATIONS #\n\n    def __hash__(self):\n        \"\"\"\"\"\"\n        return hash(self.toordinal())\n\n    def __eq__(self, other):\n        \"\"\"`==` comparison with :class:`.Date` or :class:`datetime.date`.\"\"\"\n        if isinstance(other, (Date, date)):\n            return self.toordinal() == other.toordinal()\n        return False\n\n    def __ne__(self, other):\n        \"\"\"`!=` comparison with :class:`.Date` or :class:`datetime.date`.\"\"\"\n        return not self.__eq__(other)\n\n    def __lt__(self, other):\n        \"\"\"`<` comparison with :class:`.Date` or :class:`datetime.date`.\"\"\"\n        if isinstance(other, (Date, date)):\n            return self.toordinal() < other.toordinal()\n        raise TypeError(\"'<' not supported between instances of 'Date' and %r\" % type(other).__name__)\n\n    def __le__(self, other):\n        \"\"\"`<=` comparison with :class:`.Date` or :class:`datetime.date`.\"\"\"\n        if isinstance(other, (Date, date)):\n            return self.toordinal() <= other.toordinal()\n        raise TypeError(\"'<=' not supported between instances of 'Date' and %r\" % type(other).__name__)\n\n    def __ge__(self, other):\n        \"\"\"`>=` comparison with :class:`.Date` or :class:`datetime.date`.\"\"\"\n        if isinstance(other, (Date, date)):\n            return self.toordinal() >= other.toordinal()\n        raise TypeError(\"'>=' not supported between instances of 'Date' and %r\" % type(other).__name__)\n\n    def __gt__(self, other):\n        \"\"\"`>` comparison with :class:`.Date` or :class:`datetime.date`.\"\"\"\n        if isinstance(other, (Date, date)):\n            return self.toordinal() > other.toordinal()\n        raise TypeError(\"'>' not supported between instances of 'Date' and %r\" % type(other).__name__)\n\n    def __add__(self, other):\n        \"\"\"Add a :class:`.Duration`.\n\n        :rtype: Date\n\n        :raises ValueError: if the added duration has a time component.\n        \"\"\"\n        def add_months(d, months):\n            years, months = symmetric_divmod(months, 12)\n            year = d.__year + years\n            month = d.__month + months\n            while month > 12:\n                year += 1\n                month -= 12\n            while month < 1:\n                year -= 1\n                month += 12\n            d.__year = year\n            d.__month = month\n\n        def add_days(d, days):\n            assert 1 <= d.__day <= 28 or -28 <= d.__day <= -1\n            if d.__day >= 1:\n                new_days = d.__day + days\n                if 1 <= new_days <= 27:\n                    d.__day = new_days\n                    return\n            d0 = Date.from_ordinal(d.__ordinal + days)\n            d.__year, d.__month, d.__day = d0.__year, d0.__month, d0.__day\n\n        if isinstance(other, Duration):\n            if other.seconds or other.nanoseconds:\n                raise ValueError(\"Cannot add a Duration with seconds or \"\n                                 \"nanoseconds to a Date\")\n            if other.months == other.days == 0:\n                return self\n            new_date = self.replace()\n            # Add days before months as the former sometimes\n            # requires the current ordinal to be correct.\n            if other.days:\n                add_days(new_date, other.days)\n            if other.months:\n                add_months(new_date, other.months)\n            new_date.__ordinal = self.__calc_ordinal(new_date.year, new_date.month, new_date.day)\n            return new_date\n        return NotImplemented\n\n    def __sub__(self, other):\n        \"\"\"Subtract a :class:`.Date` or :class:`.Duration`.\n\n        :returns: If a :class:`.Date` is subtracted, the time between the two\n            dates is returned as :class:`.Duration`. If a :class:`.Duration` is\n            subtracted, a new :class:`.Date` is returned.\n        :rtype: Date or Duration\n\n        :raises ValueError: if the added duration has a time component.\n        \"\"\"\n        if isinstance(other, (Date, date)):\n            return Duration(days=(self.toordinal() - other.toordinal()))\n        try:\n            return self.__add__(-other)\n        except TypeError:\n            return NotImplemented\n\n    def __copy__(self):\n        return self.__new(self.__ordinal, self.__year, self.__month, self.__day)\n\n    def __deepcopy__(self, *args, **kwargs):\n        return self.__copy__()\n\n    # INSTANCE METHODS #\n\n    def replace(self, **kwargs):\n        \"\"\"Return a :class:`.Date` with one or more components replaced.\n\n        :Keyword Arguments:\n           * **year** (`int`): overwrite the year -\n             default: `self.year`\n           * **month** (`int`): overwrite the month -\n             default: `self.month`\n           * **day** (`int`): overwrite the day -\n             default: `self.day`\n        \"\"\"\n        return Date(kwargs.get(\"year\", self.__year),\n                    kwargs.get(\"month\", self.__month),\n                    kwargs.get(\"day\", self.__day))\n\n    def time_tuple(self):\n        \"\"\"Convert the date to :class:`time.struct_time`.\n\n        :rtype: time.struct_time\n        \"\"\"\n        _, _, day_of_week = self.year_week_day\n        _, day_of_year = self.year_day\n        return struct_time((self.year, self.month, self.day, 0, 0, 0, day_of_week - 1, day_of_year, -1))\n\n    def to_ordinal(self):\n        \"\"\"The date's proleptic Gregorian ordinal.\n\n        The corresponding class method for the reverse ordinal-to-date\n        transformation is :meth:`.Date.from_ordinal`.\n\n        :rtype: int\n        \"\"\"\n        return self.__ordinal\n\n    def to_clock_time(self, epoch):\n        \"\"\"Convert the date to :class:`ClockTime` relative to `epoch`.\n\n        :param epoch: the epoch to which the date is relative\n        :type epoch: Date\n\n        :rtype: ClockTime\n        \"\"\"\n        try:\n            return ClockTime(86400 * (self.to_ordinal() - epoch.to_ordinal()))\n        except AttributeError:\n            raise TypeError(\"Epoch has no ordinal value\")\n\n    def to_native(self):\n        \"\"\"Convert to a native Python :class:`datetime.date` value.\n\n        :rtype: datetime.date\n        \"\"\"\n        return date.fromordinal(self.to_ordinal())\n\n    def weekday(self):\n        \"\"\"The day of the week where Monday is 0 and Sunday is 6.\n\n        :rtype: int\n        \"\"\"\n        return self.year_week_day[2] - 1\n\n    def iso_weekday(self):\n        \"\"\"The day of the week where Monday is 1 and Sunday is 7.\n\n        :rtype: int\n        \"\"\"\n        return self.year_week_day[2]\n\n    def iso_calendar(self):\n        \"\"\"Alias for :attr:`.year_week_day`\"\"\"\n        return self.year_week_day\n\n    def iso_format(self):\n        \"\"\"Return the :class:`.Date` as ISO formatted string.\n\n        :rtype: str\n        \"\"\"\n        if self.__ordinal == 0:\n            return \"0000-00-00\"\n        return \"%04d-%02d-%02d\" % self.year_month_day\n\n    def __repr__(self):\n        \"\"\"\"\"\"\n        if self.__ordinal == 0:\n            return \"neo4j.time.ZeroDate\"\n        return \"neo4j.time.Date(%r, %r, %r)\" % self.year_month_day\n\n    def __str__(self):\n        \"\"\"\"\"\"\n        return self.iso_format()\n\n    def __format__(self, format_spec):\n        \"\"\"\"\"\"\n        raise NotImplementedError()\n\n\nDate.min = Date.from_ordinal(1)\nDate.max = Date.from_ordinal(3652059)\nDate.resolution = Duration(days=1)\n\n#: A :class:`neo4j.time.Date` instance set to `0000-00-00`.\n#: This has an ordinal value of `0`.\nZeroDate = object.__new__(Date)\n\n\nclass Time(metaclass=TimeType):\n    \"\"\"Time of day.\n\n    The :class:`.Time` class is a nanosecond-precision drop-in replacement for\n    the standard library :class:`datetime.time` class.\n\n    A high degree of API compatibility with the standard library classes is\n    provided.\n\n    :class:`neo4j.time.Time` objects introduce the concept of ``ticks``.\n    This is simply a count of the number of nanoseconds since midnight,\n    in many ways analogous to the :class:`neo4j.time.Date` ordinal.\n    `ticks` values are integers, with a minimum value of `0` and a maximum\n    of `86_399_999_999_999`.\n\n    Local times are represented by :class:`.Time` with no ``tzinfo``.\n\n    :param hour: the hour of the time. Must be in range 0 <= hour < 24.\n    :type hour: int\n    :param minute: the minute of the time. Must be in range 0 <= minute < 60.\n    :type minute: int\n    :param second: the second of the time. Must be in range 0 <= second < 60.\n    :type second: int\n    :param nanosecond: the nanosecond of the time.\n        Must be in range 0 <= nanosecond < 999999999.\n    :type nanosecond: int\n    :param tzinfo: timezone or None to get a local :class:`.Time`.\n    :type tzinfo: datetime.tzinfo or None\n\n    :raises ValueError: if one of the parameters is out of range.\n    \"\"\"\n\n    # CONSTRUCTOR #\n\n    def __new__(cls, hour=0, minute=0, second=0, nanosecond=0, tzinfo=None):\n        hour, minute, second, nanosecond = cls.__normalize_nanosecond(\n            hour, minute, second, nanosecond\n        )\n        ticks = (3600000000000 * hour\n                 + 60000000000 * minute\n                 + 1000000000 * second\n                 + nanosecond)\n        return cls.__new(ticks, hour, minute, second, nanosecond, tzinfo)\n\n    @classmethod\n    def __new(cls, ticks, hour, minute, second, nanosecond, tzinfo):\n        instance = object.__new__(cls)\n        instance.__ticks = int(ticks)\n        instance.__hour = int(hour)\n        instance.__minute = int(minute)\n        instance.__second = int(second)\n        instance.__nanosecond = int(nanosecond)\n        instance.__tzinfo = tzinfo\n        return instance\n\n    def __getattr__(self, name):\n        \"\"\"Map standard library attribute names to local attribute names,\n        for compatibility.\n        \"\"\"\n        try:\n            return {\n                \"isoformat\": self.iso_format,\n                \"utcoffset\": self.utc_offset,\n            }[name]\n        except KeyError:\n            raise AttributeError(\"Date has no attribute %r\" % name)\n\n    # CLASS METHODS #\n\n    @classmethod\n    def now(cls, tz=None):\n        \"\"\"Get the current time.\n\n        :param tz: optional timezone\n        :type tz: datetime.tzinfo\n        :rtype: Time\n\n        :raises OverflowError: if the timestamp is out of the range of values\n            supported by the platform C localtime() function. It’s common for\n            this to be restricted to years from 1970 through 2038.\n        \"\"\"\n        if tz is None:\n            return cls.from_clock_time(Clock().local_time(), UnixEpoch)\n        else:\n            return (\n                DateTime.utc_now()\n                .replace(tzinfo=timezone.utc).astimezone(tz)\n                .timetz()\n            )\n\n    @classmethod\n    def utc_now(cls):\n        \"\"\"Get the current time as UTC local time.\n\n        :rtype: Time\n        \"\"\"\n        return cls.from_clock_time(Clock().utc_time(), UnixEpoch)\n\n    @classmethod\n    def from_iso_format(cls, s):\n        \"\"\"Parse a ISO formatted time string.\n\n        Accepted formats:\n            Local times:\n                'hh'\n                'hh:mm'\n                'hh:mm:ss'\n                'hh:mm:ss.ssss...'\n            Times with timezones (UTC offset):\n                '<local time>+hh:mm'\n                '<local time>+hh:mm:ss'\n                '<local time>+hh:mm:ss.ssss....'\n                '<local time>-hh:mm'\n                '<local time>-hh:mm:ss'\n                '<local time>-hh:mm:ss.ssss....'\n\n                Where the UTC offset will only respect hours and minutes.\n                Seconds and sub-seconds are ignored.\n\n        :param s: String to parse\n        :type s: str\n\n        :rtype: Time\n\n        :raises ValueError: if the string does not match the required format.\n        \"\"\"\n        from pytz import FixedOffset\n        m = TIME_ISO_PATTERN.match(s)\n        if m:\n            hour = int(m.group(1))\n            minute = int(m.group(3) or 0)\n            second = int(m.group(6) or 0)\n            nanosecond = m.group(7)\n            if nanosecond:\n                nanosecond = int(nanosecond[1:10].ljust(9, \"0\"))\n            else:\n                nanosecond = 0\n            if m.group(8) is None:\n                return cls(hour, minute, second, nanosecond)\n            else:\n                offset_multiplier = 1 if m.group(9) == \"+\" else -1\n                offset_hour = int(m.group(10))\n                offset_minute = int(m.group(11))\n                # pytz only supports offsets of minute resolution\n                # so we can ignore this part\n                # offset_second = float(m.group(13) or 0.0)\n                offset = 60 * offset_hour + offset_minute\n                return cls(hour, minute, second, nanosecond,\n                           tzinfo=FixedOffset(offset_multiplier * offset))\n        raise ValueError(\"Time string is not in ISO format\")\n\n", "metadata": {"ground_truth": "    @classmethod\n    def from_ticks(cls, ticks, tz=None):\n        \"\"\"Create a time from ticks (nanoseconds since midnight).\n\n        :param ticks: nanoseconds since midnight\n        :type ticks: int\n        :param tz: optional timezone\n        :type tz: datetime.tzinfo\n\n        :rtype: Time\n\n        :raises ValueError: if ticks is out of bounds\n            (0 <= ticks < 86400000000000)\n        \"\"\"\n        if not isinstance(ticks, int):\n            raise TypeError(\"Ticks must be int\")\n        if 0 <= ticks < 86400000000000:\n            second, nanosecond = divmod(ticks, NANO_SECONDS)\n            minute, second = divmod(second, 60)\n            hour, minute = divmod(minute, 60)\n            return cls.__new(ticks, hour, minute, second, nanosecond, tz)\n        raise ValueError(\"Ticks out of range (0..86400000000000)\")\n", "fpath_tuple": ["neo4j", "time", "__init__.py"], "function_name": "from_ticks", "lineno": 1508, "context_start_lineno": 0, "_id": "62e60723d76274f8a4026b76", "task_id": "neo4j/id16"}}
{"prompt": "    @classmethod\n    def protocol_handlers(cls, protocol_version=None):\n        \"\"\" Return a dictionary of available Bolt protocol handlers,\n        keyed by version tuple. If an explicit protocol version is\n        provided, the dictionary will contain either zero or one items,\n        depending on whether that version is supported. If no protocol\n        version is provided, all available versions will be returned.\n\n        :param protocol_version: tuple identifying a specific protocol\n            version (e.g. (3, 5)) or None\n        :return: dictionary of version tuple to handler class for all\n            relevant and supported protocol versions\n        :raise TypeError: if protocol version is not passed in a tuple\n        \"\"\"", "current_file": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport abc\nimport asyncio\nfrom collections import deque\nfrom logging import getLogger\nfrom time import perf_counter\n\nfrom ..._async_compat.network import AsyncBoltSocket\nfrom ..._async_compat.util import AsyncUtil\nfrom ..._codec.hydration import v1 as hydration_v1\nfrom ..._codec.packstream import v1 as packstream_v1\nfrom ..._conf import PoolConfig\nfrom ..._exceptions import (\n    BoltError,\n    BoltHandshakeError,\n    SocketDeadlineExceeded,\n)\nfrom ..._meta import get_user_agent\nfrom ...addressing import Address\nfrom ...api import (\n    ServerInfo,\n    Version,\n)\nfrom ...exceptions import (\n    AuthError,\n    DriverError,\n    IncompleteCommit,\n    ServiceUnavailable,\n    SessionExpired,\n)\nfrom ._common import (\n    AsyncInbox,\n    AsyncOutbox,\n    CommitResponse,\n)\n\n\n# Set up logger\nlog = getLogger(\"neo4j\")\n\n\nclass AsyncBolt:\n    \"\"\" Server connection for Bolt protocol.\n\n    A :class:`.Bolt` should be constructed following a\n    successful .open()\n\n    Bolt handshake and takes the socket over which\n    the handshake was carried out.\n    \"\"\"\n\n    # TODO: let packer/unpacker know of hydration (give them hooks?)\n    # TODO: make sure query parameter dehydration gets clear error message.\n\n    PACKER_CLS = packstream_v1.Packer\n    UNPACKER_CLS = packstream_v1.Unpacker\n    HYDRATION_HANDLER_CLS = hydration_v1.HydrationHandler\n\n    MAGIC_PREAMBLE = b\"\\x60\\x60\\xB0\\x17\"\n\n    PROTOCOL_VERSION = None\n\n    # flag if connection needs RESET to go back to READY state\n    is_reset = False\n\n    # The socket\n    in_use = False\n\n    # When the connection was last put back into the pool\n    idle_since = float(\"-inf\")\n\n    # The socket\n    _closing = False\n    _closed = False\n\n    # The socket\n    _defunct = False\n\n    #: The pool of which this connection is a member\n    pool = None\n\n    # Store the id of the most recent ran query to be able to reduce sent bits by\n    # using the default (-1) to refer to the most recent query when pulling\n    # results for it.\n    most_recent_qid = None\n\n    def __init__(self, unresolved_address, sock, max_connection_lifetime, *,\n                 auth=None, user_agent=None, routing_context=None):\n        self.unresolved_address = unresolved_address\n        self.socket = sock\n        self.local_port = self.socket.getsockname()[1]\n        self.server_info = ServerInfo(Address(sock.getpeername()),\n                                      self.PROTOCOL_VERSION)\n        # so far `connection.recv_timeout_seconds` is the only available\n        # configuration hint that exists. Therefore, all hints can be stored at\n        # connection level. This might change in the future.\n        self.configuration_hints = {}\n        self.patch = {}\n        self.outbox = AsyncOutbox(\n            self.socket, on_error=self._set_defunct_write,\n            packer_cls=self.PACKER_CLS\n        )\n        self.inbox = AsyncInbox(\n            self.socket, on_error=self._set_defunct_read,\n            unpacker_cls=self.UNPACKER_CLS\n        )\n        self.hydration_handler = self.HYDRATION_HANDLER_CLS()\n        self.responses = deque()\n        self._max_connection_lifetime = max_connection_lifetime\n        self._creation_timestamp = perf_counter()\n        self.routing_context = routing_context\n        self.idle_since = perf_counter()\n\n        # Determine the user agent\n        if user_agent:\n            self.user_agent = user_agent\n        else:\n            self.user_agent = get_user_agent()\n\n        # Determine auth details\n        if not auth:\n            self.auth_dict = {}\n        elif isinstance(auth, tuple) and 2 <= len(auth) <= 3:\n            from neo4j import Auth\n            self.auth_dict = vars(Auth(\"basic\", *auth))\n        else:\n            try:\n                self.auth_dict = vars(auth)\n            except (KeyError, TypeError):\n                raise AuthError(\"Cannot determine auth details from %r\" % auth)\n\n        # Check for missing password\n        try:\n            credentials = self.auth_dict[\"credentials\"]\n        except KeyError:\n            pass\n        else:\n            if credentials is None:\n                raise AuthError(\"Password cannot be None\")\n\n    def __del__(self):\n        if not asyncio.iscoroutinefunction(self.close):\n            self.close()\n\n    @property\n    @abc.abstractmethod\n    def supports_multiple_results(self):\n        \"\"\" Boolean flag to indicate if the connection version supports multiple\n        queries to be buffered on the server side (True) or if all results need\n        to be eagerly pulled before sending the next RUN (False).\n        \"\"\"\n        pass\n\n    @property\n    @abc.abstractmethod\n    def supports_multiple_databases(self):\n        \"\"\" Boolean flag to indicate if the connection version supports multiple\n        databases.\n        \"\"\"\n        pass\n\n", "metadata": {"ground_truth": "    @classmethod\n    def protocol_handlers(cls, protocol_version=None):\n        \"\"\" Return a dictionary of available Bolt protocol handlers,\n        keyed by version tuple. If an explicit protocol version is\n        provided, the dictionary will contain either zero or one items,\n        depending on whether that version is supported. If no protocol\n        version is provided, all available versions will be returned.\n\n        :param protocol_version: tuple identifying a specific protocol\n            version (e.g. (3, 5)) or None\n        :return: dictionary of version tuple to handler class for all\n            relevant and supported protocol versions\n        :raise TypeError: if protocol version is not passed in a tuple\n        \"\"\"\n\n        # Carry out Bolt subclass imports locally to avoid circular dependency issues.\n        from ._bolt3 import AsyncBolt3\n        from ._bolt4 import (\n            AsyncBolt4x1,\n            AsyncBolt4x2,\n            AsyncBolt4x3,\n            AsyncBolt4x4,\n        )\n        from ._bolt5 import AsyncBolt5x0\n\n        handlers = {\n            AsyncBolt3.PROTOCOL_VERSION: AsyncBolt3,\n            # 4.0 unsupported because no space left in the handshake\n            AsyncBolt4x1.PROTOCOL_VERSION: AsyncBolt4x1,\n            AsyncBolt4x2.PROTOCOL_VERSION: AsyncBolt4x2,\n            AsyncBolt4x3.PROTOCOL_VERSION: AsyncBolt4x3,\n            AsyncBolt4x4.PROTOCOL_VERSION: AsyncBolt4x4,\n            AsyncBolt5x0.PROTOCOL_VERSION: AsyncBolt5x0,\n        }\n\n        if protocol_version is None:\n            return handlers\n\n        if not isinstance(protocol_version, tuple):\n            raise TypeError(\"Protocol version must be specified as a tuple\")\n\n        if protocol_version in handlers:\n            return {protocol_version: handlers[protocol_version]}\n\n        return {}\n", "fpath_tuple": ["neo4j", "_async", "io", "_bolt.py"], "function_name": "protocol_handlers", "lineno": 179, "context_start_lineno": 0, "_id": "62e60873d76274f8a4026bd8", "task_id": "neo4j/id17"}}
{"prompt": "    @classmethod\n    def from_raw_values(cls, values):\n        \"\"\"Create a Bookmarks object from a list of raw bookmark string values.\n\n        You should not need to use this method unless you want to deserialize\n        bookmarks.\n\n        :param values: ASCII string values (raw bookmarks)\n        :type values: Iterable[str]\n        \"\"\"", "current_file": "# Copyright (c) \"Neo4j\"\n# Neo4j Sweden AB [https://neo4j.com]\n#\n# This file is part of Neo4j.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\" Base classes and helpers.\n\"\"\"\n\n\nfrom urllib.parse import (\n    parse_qs,\n    urlparse,\n)\n\nfrom ._meta import deprecated\nfrom .exceptions import ConfigurationError\n\n\nREAD_ACCESS = \"READ\"\nWRITE_ACCESS = \"WRITE\"\n\nDRIVER_BOLT = \"DRIVER_BOLT\"\nDRIVER_NEO4j = \"DRIVER_NEO4J\"\n\nSECURITY_TYPE_NOT_SECURE = \"SECURITY_TYPE_NOT_SECURE\"\nSECURITY_TYPE_SELF_SIGNED_CERTIFICATE = \"SECURITY_TYPE_SELF_SIGNED_CERTIFICATE\"\nSECURITY_TYPE_SECURE = \"SECURITY_TYPE_SECURE\"\n\nURI_SCHEME_BOLT = \"bolt\"\nURI_SCHEME_BOLT_SELF_SIGNED_CERTIFICATE = \"bolt+ssc\"\nURI_SCHEME_BOLT_SECURE = \"bolt+s\"\n\nURI_SCHEME_NEO4J = \"neo4j\"\nURI_SCHEME_NEO4J_SELF_SIGNED_CERTIFICATE = \"neo4j+ssc\"\nURI_SCHEME_NEO4J_SECURE = \"neo4j+s\"\n\nURI_SCHEME_BOLT_ROUTING = \"bolt+routing\"\n\n# TODO: 6.0 - remove TRUST constants\nTRUST_SYSTEM_CA_SIGNED_CERTIFICATES = \"TRUST_SYSTEM_CA_SIGNED_CERTIFICATES\"  # Default\nTRUST_ALL_CERTIFICATES = \"TRUST_ALL_CERTIFICATES\"\n\nSYSTEM_DATABASE = \"system\"\nDEFAULT_DATABASE = None  # Must be a non string hashable value\n\n\n# TODO: This class is not tested\nclass Auth:\n    \"\"\"Container for auth details.\n\n    :param scheme: specifies the type of authentication, examples: \"basic\",\n                   \"kerberos\"\n    :type scheme: str\n    :param principal: specifies who is being authenticated\n    :type principal: str or None\n    :param credentials: authenticates the principal\n    :type credentials: str or None\n    :param realm: specifies the authentication provider\n    :type realm: str or None\n    :param parameters: extra key word parameters passed along to the\n                       authentication provider\n    :type parameters: Dict[str, Any]\n    \"\"\"\n\n    def __init__(self, scheme, principal, credentials, realm=None, **parameters):\n        self.scheme = scheme\n        # Neo4j servers pre 4.4 require the principal field to always be\n        # present. Therefore, we transmit it even if it's an empty sting.\n        if principal is not None:\n            self.principal = principal\n        if credentials:\n            self.credentials = credentials\n        if realm:\n            self.realm = realm\n        if parameters:\n            self.parameters = parameters\n\n\n# For backwards compatibility\nAuthToken = Auth\n\n\ndef basic_auth(user, password, realm=None):\n    \"\"\"Generate a basic auth token for a given user and password.\n\n    This will set the scheme to \"basic\" for the auth token.\n\n    :param user: user name, this will set the\n    :type user: str\n    :param password: current password, this will set the credentials\n    :type password: str\n    :param realm: specifies the authentication provider\n    :type realm: str or None\n\n    :return: auth token for use with :meth:`GraphDatabase.driver` or\n        :meth:`AsyncGraphDatabase.driver`\n    :rtype: :class:`neo4j.Auth`\n    \"\"\"\n    return Auth(\"basic\", user, password, realm)\n\n\ndef kerberos_auth(base64_encoded_ticket):\n    \"\"\"Generate a kerberos auth token with the base64 encoded ticket.\n\n    This will set the scheme to \"kerberos\" for the auth token.\n\n    :param base64_encoded_ticket: a base64 encoded service ticket, this will set\n                                  the credentials\n    :type base64_encoded_ticket: str\n\n    :return: auth token for use with :meth:`GraphDatabase.driver` or\n        :meth:`AsyncGraphDatabase.driver`\n    :rtype: :class:`neo4j.Auth`\n    \"\"\"\n    return Auth(\"kerberos\", \"\", base64_encoded_ticket)\n\n\ndef bearer_auth(base64_encoded_token):\n    \"\"\"Generate an auth token for Single-Sign-On providers.\n\n    This will set the scheme to \"bearer\" for the auth token.\n\n    :param base64_encoded_token: a base64 encoded authentication token generated\n                                 by a Single-Sign-On provider.\n    :type base64_encoded_token: str\n\n    :return: auth token for use with :meth:`GraphDatabase.driver` or\n        :meth:`AsyncGraphDatabase.driver`\n    :rtype: :class:`neo4j.Auth`\n    \"\"\"\n    return Auth(\"bearer\", None, base64_encoded_token)\n\n\ndef custom_auth(principal, credentials, realm, scheme, **parameters):\n    \"\"\"Generate a custom auth token.\n\n    :param principal: specifies who is being authenticated\n    :type principal: str or None\n    :param credentials: authenticates the principal\n    :type credentials: str or None\n    :param realm: specifies the authentication provider\n    :type realm: str or None\n    :param scheme: specifies the type of authentication\n    :type scheme: str or None\n    :param parameters: extra key word parameters passed along to the\n                       authentication provider\n    :type parameters: Dict[str, Any]\n\n    :return: auth token for use with :meth:`GraphDatabase.driver` or\n        :meth:`AsyncGraphDatabase.driver`\n    :rtype: :class:`neo4j.Auth`\n    \"\"\"\n    return Auth(scheme, principal, credentials, realm, **parameters)\n\n\n# TODO 6.0 - remove this class\nclass Bookmark:\n    \"\"\"A Bookmark object contains an immutable list of bookmark string values.\n\n    .. deprecated:: 5.0\n        `Bookmark` will be removed in version 6.0.\n        Use :class:`Bookmarks` instead.\n\n    :param values: ASCII string values\n    \"\"\"\n\n    @deprecated(\"Use the `Bookmarks`` class instead.\")\n    def __init__(self, *values):\n        if values:\n            bookmarks = []\n            for ix in values:\n                try:\n                    if ix:\n                        ix.encode(\"ascii\")\n                        bookmarks.append(ix)\n                except UnicodeEncodeError as e:\n                    raise ValueError(\"The value {} is not ASCII\".format(ix))\n            self._values = frozenset(bookmarks)\n        else:\n            self._values = frozenset()\n\n    def __repr__(self):\n        \"\"\"\n        :return: repr string with sorted values\n        \"\"\"\n        return \"<Bookmark values={{{}}}>\".format(\", \".join([\"'{}'\".format(ix) for ix in sorted(self._values)]))\n\n    def __bool__(self):\n        return bool(self._values)\n\n    @property\n    def values(self):\n        \"\"\"\n        :return: immutable list of bookmark string values\n        :rtype: frozenset\n        \"\"\"\n        return self._values\n\n\nclass Bookmarks:\n    \"\"\"Container for an immutable set of bookmark string values.\n\n    Bookmarks are used to causally chain session.\n    See :meth:`Session.last_bookmarks` or :meth:`AsyncSession.last_bookmarks`\n    for more information.\n\n    Use addition to combine multiple Bookmarks objects::\n\n        bookmarks3 = bookmarks1 + bookmarks2\n    \"\"\"\n\n    def __init__(self):\n        self._raw_values = frozenset()\n\n    def __repr__(self):\n        \"\"\"\n        :return: repr string with sorted values\n        \"\"\"\n        return \"<Bookmarks values={{{}}}>\".format(\n            \", \".join(map(repr, sorted(self._raw_values)))\n        )\n\n    def __bool__(self):\n        return bool(self._raw_values)\n\n    def __add__(self, other):\n        if isinstance(other, Bookmarks):\n            if not other:\n                return self\n            ret = self.__class__()\n            ret._raw_values = self._raw_values | other._raw_values\n            return ret\n        return NotImplemented\n\n    @property\n    def raw_values(self):\n        \"\"\"The raw bookmark values.\n\n        You should not need to access them unless you want to serialize\n        bookmarks.\n\n        :return: immutable list of bookmark string values\n        :rtype: frozenset[str]\n        \"\"\"\n        return self._raw_values\n\n", "metadata": {"ground_truth": "    @classmethod\n    def from_raw_values(cls, values):\n        \"\"\"Create a Bookmarks object from a list of raw bookmark string values.\n\n        You should not need to use this method unless you want to deserialize\n        bookmarks.\n\n        :param values: ASCII string values (raw bookmarks)\n        :type values: Iterable[str]\n        \"\"\"\n        obj = cls()\n        bookmarks = []\n        for value in values:\n            if not isinstance(value, str):\n                raise TypeError(\"Raw bookmark values must be str. \"\n                                \"Found {}\".format(type(value)))\n            try:\n                value.encode(\"ascii\")\n            except UnicodeEncodeError as e:\n                raise ValueError(f\"The value {value} is not ASCII\") from e\n            bookmarks.append(value)\n        obj._raw_values = frozenset(bookmarks)\n        return obj\n", "fpath_tuple": ["neo4j", "api.py"], "function_name": "from_raw_values", "lineno": 259, "context_start_lineno": 0, "_id": "62e60e3bd76274f8a4026d1a", "task_id": "neo4j/id18"}}
