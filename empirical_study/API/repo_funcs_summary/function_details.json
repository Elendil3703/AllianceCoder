[
    {
        "name": "__init__",
        "docstring": "Initializes an incompatible currency error message.",
        "args": [
            "self",
            "ccy1",
            "ccy2",
            "operation"
        ],
        "defaults": [
            "'<Unspecified>'"
        ],
        "code": "    def __init__(self, ccy1: Currency, ccy2: Currency, operation: str = \"<Unspecified>\") -> None:\n        \"\"\"\n        Initializes an incompatible currency error message.\n        \"\"\"\n        ## Keep sloys:\n        self.ccy1 = ccy1\n        self.ccy2 = ccy2\n        self.operation = operation\n\n        ## Call super:\n        super().__init__(f\"{ccy1.code} vs {ccy2.code} are incompatible for operation '{operation}'.\")",
        "class": "IncompatibleCurrencyError",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "is_equal",
        "docstring": "Checks the equality of two money objects.\n\nIn particular:\n\n1. ``True`` if ``other`` is a money object **and** all slots are same.\n2. ``False`` otherwise.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def is_equal(self, other: Any) -> bool:\n        \"\"\"\n        Checks the equality of two money objects.\n\n        In particular:\n\n        1. ``True`` if ``other`` is a money object **and** all slots are same.\n        2. ``False`` otherwise.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "as_boolean",
        "docstring": "Returns the logical representation of the money object.\n\nIn particular:\n\n1. ``False`` if money is *undefined* **or** money quantity is ``zero``.\n2. ``True`` otherwise.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def as_boolean(self) -> bool:\n        \"\"\"\n        Returns the logical representation of the money object.\n\n        In particular:\n\n        1. ``False`` if money is *undefined* **or** money quantity is ``zero``.\n        2. ``True`` otherwise.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "as_float",
        "docstring": "Returns the quantity as a ``float`` if *defined*, raises class:`MonetaryOperationException` otherwise.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def as_float(self) -> float:\n        \"\"\"\n        Returns the quantity as a ``float`` if *defined*, raises class:`MonetaryOperationException` otherwise.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "as_integer",
        "docstring": "Returns the quantity as an ``int`` if *defined*, raises class:`MonetaryOperationException` otherwise.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def as_integer(self) -> int:\n        \"\"\"\n        Returns the quantity as an ``int`` if *defined*, raises class:`MonetaryOperationException` otherwise.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "abs",
        "docstring": "Returns the absolute money if *defined*, itself otherwise.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def abs(self) -> \"Money\":\n        \"\"\"\n        Returns the absolute money if *defined*, itself otherwise.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "negative",
        "docstring": "Negates the quantity of the monetary value if *defined*, itself otherwise.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def negative(self) -> \"Money\":\n        \"\"\"\n        Negates the quantity of the monetary value if *defined*, itself otherwise.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "positive",
        "docstring": "Returns same monetary value if *defined*, itself otherwise.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def positive(self) -> \"Money\":\n        \"\"\"\n        Returns same monetary value if *defined*, itself otherwise.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "round",
        "docstring": "Rounds the quantity of the monetary value to ``ndigits`` by using ``HALF_EVEN`` method if *defined*, itself\notherwise.",
        "args": [
            "self",
            "ndigits"
        ],
        "defaults": [
            "0"
        ],
        "code": "    def round(self, ndigits: int = 0) -> \"Money\":\n        \"\"\"\n        Rounds the quantity of the monetary value to ``ndigits`` by using ``HALF_EVEN`` method if *defined*, itself\n        otherwise.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "add",
        "docstring": "Performs monetary addition on the money object and the given ``other`` money object.\n\nNote that::\n\n1. Raises :class:`IncompatibleCurrencyError` if currencies do not match.\n2. If any of the operands are undefined, returns the other one conveniently.\n3. Dates are carried forward as a result of addition of two defined money objects.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def add(self, other: \"Money\") -> \"Money\":\n        \"\"\"\n        Performs monetary addition on the money object and the given ``other`` money object.\n\n        Note that::\n\n        1. Raises :class:`IncompatibleCurrencyError` if currencies do not match.\n        2. If any of the operands are undefined, returns the other one conveniently.\n        3. Dates are carried forward as a result of addition of two defined money objects.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "scalar_add",
        "docstring": "Performs scalar addition on the quantity of the money.\n\nNote that undefined money object is returned as is.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def scalar_add(self, other: Numeric) -> \"Money\":\n        \"\"\"\n        Performs scalar addition on the quantity of the money.\n\n        Note that undefined money object is returned as is.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "subtract",
        "docstring": "Performs monetary subtraction on the money object and the given ``other`` money object.\n\nNote that::\n\n1. Raises :class:`IncompatibleCurrencyError` if currencies do not match.\n2. If any of the operands are undefined, returns the other one conveniently.\n3. Dates are carried forward as a result of addition of two defined money objects.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def subtract(self, other: \"Money\") -> \"Money\":\n        \"\"\"\n        Performs monetary subtraction on the money object and the given ``other`` money object.\n\n        Note that::\n\n        1. Raises :class:`IncompatibleCurrencyError` if currencies do not match.\n        2. If any of the operands are undefined, returns the other one conveniently.\n        3. Dates are carried forward as a result of addition of two defined money objects.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "scalar_subtract",
        "docstring": "Performs scalar subtraction on the quantity of the money.\n\nNote that undefined money object is returned as is.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def scalar_subtract(self, other: Numeric) -> \"Money\":\n        \"\"\"\n        Performs scalar subtraction on the quantity of the money.\n\n        Note that undefined money object is returned as is.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "multiply",
        "docstring": "Performs scalar multiplication.\n\nNote that undefined money object is returned as is.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def multiply(self, other: Numeric) -> \"Money\":\n        \"\"\"\n        Performs scalar multiplication.\n\n        Note that undefined money object is returned as is.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "divide",
        "docstring": "Performs ordinary division on the money object if *defined*, itself otherwise.\n\nNote that division by zero yields an undefined money object.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def divide(self, other: Numeric) -> \"Money\":\n        \"\"\"\n        Performs ordinary division on the money object if *defined*, itself otherwise.\n\n        Note that division by zero yields an undefined money object.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "floor_divide",
        "docstring": "Performs floor division on the money object if *defined*, itself otherwise.\n\nNote that division by zero yields an undefined money object.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def floor_divide(self, other: Numeric) -> \"Money\":\n        \"\"\"\n        Performs floor division on the money object if *defined*, itself otherwise.\n\n        Note that division by zero yields an undefined money object.\n\n        \"\"\"\n        raise NotImplementedError",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "lt",
        "docstring": "Applies \"less than\" comparison against ``other`` money.\n\nNote that::\n\n1. Undefined money objects are always less than ``other`` if ``other`` is not undefined, and\n2. :class:`IncompatibleCurrencyError` is raised when comparing two defined money objects with different\ncurrencies.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def lt(self, other: \"Money\") -> bool:\n        \"\"\"\n        Applies \"less than\" comparison against ``other`` money.\n\n        Note that::\n\n        1. Undefined money objects are always less than ``other`` if ``other`` is not undefined, and\n        2. :class:`IncompatibleCurrencyError` is raised when comparing two defined money objects with different\n        currencies.\n        \"\"\"\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "lte",
        "docstring": "Applies \"less than or equal to\" comparison against ``other`` money.\n\nNote that::\n\n1. Undefined money objects are always less than or equal to ``other``, and\n2. :class:`IncompatibleCurrencyError` is raised when comparing two defined money objects with different\ncurrencies.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def lte(self, other: \"Money\") -> bool:\n        \"\"\"\n        Applies \"less than or equal to\" comparison against ``other`` money.\n\n        Note that::\n\n        1. Undefined money objects are always less than or equal to ``other``, and\n        2. :class:`IncompatibleCurrencyError` is raised when comparing two defined money objects with different\n        currencies.\n        \"\"\"\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "gt",
        "docstring": "Applies \"greater than\" comparison against ``other`` money.\n\nNote that::\n\n1. Undefined money objects are never greater than ``other``,\n2. Defined money objects are always greater than ``other`` if other is undefined, and\n3. :class:`IncompatibleCurrencyError` is raised when comparing two defined money objects with different\ncurrencies.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def gt(self, other: \"Money\") -> bool:\n        \"\"\"\n        Applies \"greater than\" comparison against ``other`` money.\n\n        Note that::\n\n        1. Undefined money objects are never greater than ``other``,\n        2. Defined money objects are always greater than ``other`` if other is undefined, and\n        3. :class:`IncompatibleCurrencyError` is raised when comparing two defined money objects with different\n        currencies.\n        \"\"\"\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "gte",
        "docstring": "Applies \"greater than or equal to\" comparison against ``other`` money.\n\nNote that::\n\n1. Undefined money objects are never greater than or equal to ``other`` if ``other`` is defined,\n2. Undefined money objects are greater than or equal to ``other`` if ``other is undefined, and\n3. :class:`IncompatibleCurrencyError` is raised when comparing two defined money objects with different\ncurrencies.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def gte(self, other: \"Money\") -> bool:\n        \"\"\"\n        Applies \"greater than or equal to\" comparison against ``other`` money.\n\n        Note that::\n\n        1. Undefined money objects are never greater than or equal to ``other`` if ``other`` is defined,\n        2. Undefined money objects are greater than or equal to ``other`` if ``other is undefined, and\n        3. :class:`IncompatibleCurrencyError` is raised when comparing two defined money objects with different\n        currencies.\n        \"\"\"\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "with_ccy",
        "docstring": "Creates a new money object with the given currency if money is *defined*, returns itself otherwise.",
        "args": [
            "self",
            "ccy"
        ],
        "defaults": [],
        "code": "    def with_ccy(self, ccy: Currency) -> \"Money\":\n        \"\"\"\n        Creates a new money object with the given currency if money is *defined*, returns itself otherwise.\n        \"\"\"\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "with_qty",
        "docstring": "Creates a new money object with the given quantity if money is *defined*, returns itself otherwise.",
        "args": [
            "self",
            "qty"
        ],
        "defaults": [],
        "code": "    def with_qty(self, qty: Decimal) -> \"Money\":\n        \"\"\"\n        Creates a new money object with the given quantity if money is *defined*, returns itself otherwise.\n        \"\"\"\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "with_dov",
        "docstring": "Creates a new money object with the given value date if money is *defined*, returns itself otherwise.",
        "args": [
            "self",
            "dov"
        ],
        "defaults": [],
        "code": "    def with_dov(self, dov: Date) -> \"Money\":\n        \"\"\"\n        Creates a new money object with the given value date if money is *defined*, returns itself otherwise.\n        \"\"\"\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "convert",
        "docstring": "Converts the monetary value from one currency to another.\n\nRaises :class:`FXRateLookupError` if no foreign exchange rate can be found for conversion.\n\nNote that we will carry the date forward as per ``asof`` date.",
        "args": [
            "self",
            "to",
            "asof",
            "strict"
        ],
        "defaults": [
            "None",
            "False"
        ],
        "code": "    def convert(self, to: Currency, asof: Optional[Date] = None, strict: bool = False) -> \"Money\":\n        \"\"\"\n        Converts the monetary value from one currency to another.\n\n        Raises :class:`FXRateLookupError` if no foreign exchange rate can be found for conversion.\n\n        Note that we will carry the date forward as per ``asof`` date.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "of",
        "docstring": "Provides a factory method to create a new money object in a safe manner.",
        "args": [
            "cls",
            "ccy",
            "qty",
            "dov"
        ],
        "defaults": [],
        "code": "    def of(cls, ccy: Optional[Currency], qty: Optional[Decimal], dov: Optional[Date]) -> \"Money\":\n        \"\"\"\n        Provides a factory method to create a new money object in a safe manner.\n        \"\"\"\n        if qty is None or ccy is None or dov is None:\n            return NoMoney\n        return SomeMoney(ccy, ccy.quantize(qty), dov)",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "price",
        "docstring": "Returns the price representation of the money object.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def price(self) -> \"Price\":\n        \"\"\"\n        Returns the price representation of the money object.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__bool__",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __bool__(self) -> bool:\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__eq__",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __eq__(self, other: Any) -> bool:\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__abs__",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __abs__(self) -> \"Money\":\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__float__",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __float__(self) -> float:\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__int__",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __int__(self) -> int:\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__round__",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __round__(self) -> int:\n        ...",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__round__",
        "docstring": null,
        "args": [
            "self",
            "ndigits"
        ],
        "defaults": [],
        "code": "    def __round__(self, ndigits: None) -> int:\n        ...",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__round__",
        "docstring": null,
        "args": [
            "self",
            "ndigits"
        ],
        "defaults": [],
        "code": "    def __round__(self, ndigits: int) -> \"Money\":\n        ...",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__round__",
        "docstring": null,
        "args": [
            "self",
            "ndigits"
        ],
        "defaults": [
            "0"
        ],
        "code": "    def __round__(self, ndigits: Optional[int] = 0) -> Union[\"Money\", int]:\n        return self.round(ndigits or 0)",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__neg__",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __neg__(self) -> \"Money\":\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__pos__",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __pos__(self) -> \"Money\":\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__add__",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __add__(self, other: \"Money\") -> \"Money\":\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__sub__",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __sub__(self, other: \"Money\") -> \"Money\":\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__mul__",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __mul__(self, other: Numeric) -> \"Money\":\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__truediv__",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __truediv__(self, other: Numeric) -> \"Money\":\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__floordiv__",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __floordiv__(self, other: Numeric) -> \"Money\":\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__lt__",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __lt__(self, other: \"Money\") -> bool:\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__le__",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __le__(self, other: \"Money\") -> bool:\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__gt__",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __gt__(self, other: \"Money\") -> bool:\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__ge__",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __ge__(self, other: \"Money\") -> bool:\n        pass",
        "class": "Money",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "is_equal",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def is_equal(self, other: Any) -> bool:\n        return other.__class__ is SomeMoney and tuple(self) == tuple(other)",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "as_boolean",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def as_boolean(self) -> bool:\n        return self[1].__bool__()",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "as_float",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def as_float(self) -> float:\n        return self[1].__float__()",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "as_integer",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def as_integer(self) -> int:\n        return self[1].__int__()",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "abs",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def abs(self) -> \"Money\":\n        c, q, d = self\n        return SomeMoney(c, q.__abs__(), d)",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "negative",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def negative(self) -> \"Money\":\n        c, q, d = self\n        return SomeMoney(c, q.__neg__(), d)",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "positive",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def positive(self) -> \"Money\":\n        c, q, d = self\n        return SomeMoney(c, q.__pos__(), d)",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "round",
        "docstring": null,
        "args": [
            "self",
            "ndigits"
        ],
        "defaults": [
            "0"
        ],
        "code": "    def round(self, ndigits: int = 0) -> \"Money\":\n        c, q, d = self\n        dec = c.decimals\n        return SomeMoney(c, q.__round__(ndigits if ndigits < dec else dec), d)",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "add",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def add(self, other: \"Money\") -> \"Money\":\n        if other.undefined:\n            return self\n\n        c1: Currency\n        q1: Decimal\n        d1: Date\n        c2: Currency\n        q2: Decimal\n        d2: Date\n        c1, q1, d1 = self\n        c2, q2, d2 = other  # type: ignore\n\n        if c1 != c2:\n            raise IncompatibleCurrencyError(ccy1=c1, ccy2=c2, operation=\"addition\")\n\n        return SomeMoney(c1, q1 + q2, d1 if d1 > d2 else d2)",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "scalar_add",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def scalar_add(self, other: Numeric) -> \"Money\":\n        ## TODO: **try** not casting other to Decimal.\n        c, q, d = self\n        return SomeMoney(c, (q + Decimal(other)).quantize(c.quantizer), d)",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "subtract",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def subtract(self, other: \"Money\") -> \"Money\":\n        if other.undefined:\n            return self\n\n        c1: Currency\n        q1: Decimal\n        d1: Date\n        c2: Currency\n        q2: Decimal\n        d2: Date\n        c1, q1, d1 = self\n        c2, q2, d2 = other  # type: ignore\n\n        if c1 != c2:\n            raise IncompatibleCurrencyError(ccy1=c1, ccy2=c2, operation=\"subtraction\")\n\n        return SomeMoney(c1, q1 - q2, d1 if d1 > d2 else d2)",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "scalar_subtract",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def scalar_subtract(self, other: Numeric) -> \"Money\":\n        ## TODO: **try** not casting other to Decimal.\n        c, q, d = self\n        return SomeMoney(c, (q - Decimal(other)).quantize(c.quantizer), d)",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "multiply",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def multiply(self, other: Numeric) -> \"Money\":\n        ## TODO: **try** not casting other to Decimal.\n        c, q, d = self\n        return SomeMoney(c, (q * Decimal(other)).quantize(c.quantizer), d)",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "divide",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def divide(self, other: Numeric) -> \"Money\":\n        ## TODO: **try** not casting other to Decimal.\n        try:\n            c, q, d = self\n            return SomeMoney(c, (q / Decimal(other)).quantize(c.quantizer), d)\n        except (InvalidOperation, DivisionByZero):\n            return NoMoney",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "floor_divide",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def floor_divide(self, other: Numeric) -> \"Money\":\n        ## TODO: **try** not casting other to Decimal.\n        try:\n            c, q, d = self\n            return SomeMoney(c, (q // Decimal(other)).quantize(c.quantizer), d)\n        except (InvalidOperation, DivisionByZero):\n            return NoMoney",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "lt",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def lt(self, other: \"Money\") -> bool:\n        if other.undefined:\n            return False\n        elif self.ccy != other.ccy:\n            raise IncompatibleCurrencyError(ccy1=self.ccy, ccy2=other.ccy, operation=\"< comparision\")\n        return self.qty < other.qty",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "lte",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def lte(self, other: \"Money\") -> bool:\n        if other.undefined:\n            return False\n        elif self.ccy != other.ccy:\n            raise IncompatibleCurrencyError(ccy1=self.ccy, ccy2=other.ccy, operation=\"<= comparision\")\n        return self.qty <= other.qty",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "gt",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def gt(self, other: \"Money\") -> bool:\n        if other.undefined:\n            return True\n        elif self.ccy != other.ccy:\n            raise IncompatibleCurrencyError(ccy1=self.ccy, ccy2=other.ccy, operation=\"> comparision\")\n        return self.qty > other.qty",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "gte",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def gte(self, other: \"Money\") -> bool:\n        if other.undefined:\n            return True\n        elif self.ccy != other.ccy:\n            raise IncompatibleCurrencyError(ccy1=self.ccy, ccy2=other.ccy, operation=\">= comparision\")\n        return self.qty >= other.qty",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "with_ccy",
        "docstring": null,
        "args": [
            "self",
            "ccy"
        ],
        "defaults": [],
        "code": "    def with_ccy(self, ccy: Currency) -> \"Money\":\n        return SomeMoney(ccy, self[1], self[2])",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "with_qty",
        "docstring": null,
        "args": [
            "self",
            "qty"
        ],
        "defaults": [],
        "code": "    def with_qty(self, qty: Decimal) -> \"Money\":\n        c, q, d = self\n        return SomeMoney(c, qty.quantize(c.quantizer), d)",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "with_dov",
        "docstring": null,
        "args": [
            "self",
            "dov"
        ],
        "defaults": [],
        "code": "    def with_dov(self, dov: Date) -> \"Money\":\n        return SomeMoney(self[0], self[1], dov)",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "convert",
        "docstring": null,
        "args": [
            "self",
            "to",
            "asof",
            "strict"
        ],
        "defaults": [
            "None",
            "False"
        ],
        "code": "    def convert(self, to: Currency, asof: Optional[Date] = None, strict: bool = False) -> \"Money\":\n        ## Get slots:\n        ccy, qty, dov = self\n\n        ## Get date of conversion:\n        asof = asof or dov\n\n        ## Attempt to get the FX rate:\n        try:\n            rate = FXRateService.default.query(ccy, to, asof, strict)  # type: ignore\n        except AttributeError as exc:\n            if FXRateService.default is None:\n                raise ProgrammingError(\"Did you implement and set the default FX rate service?\")\n            else:\n                raise exc\n\n        ## Do we have a rate?\n        if rate is None:\n            ## Nope, shall we raise exception?\n            if strict:\n                ## Yep:\n                raise FXRateLookupError(ccy, to, asof)\n            else:\n                ## Just return NA:\n                return NoMoney\n\n        ## Compute and return:\n        return SomeMoney(to, (qty * rate.value).quantize(to.quantizer), asof)",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "price",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def price(self) -> \"Price\":\n        return SomePrice(*self)",
        "class": "SomeMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "as_boolean",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def as_boolean(self) -> bool:\n        return False",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "is_equal",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def is_equal(self, other: Any) -> bool:\n        return other.__class__ is NoneMoney",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "abs",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def abs(self) -> \"Money\":\n        return self",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "as_float",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def as_float(self) -> float:\n        raise TypeError(\"Undefined monetary values do not have quantity information.\")",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "as_integer",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def as_integer(self) -> int:\n        raise TypeError(\"Undefined monetary values do not have quantity information.\")",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "round",
        "docstring": null,
        "args": [
            "self",
            "ndigits"
        ],
        "defaults": [
            "0"
        ],
        "code": "    def round(self, ndigits: int = 0) -> \"Money\":\n        return self",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "negative",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def negative(self) -> \"Money\":\n        return self",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "positive",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def positive(self) -> \"Money\":\n        return self",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "add",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def add(self, other: \"Money\") -> \"Money\":\n        return other",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "scalar_add",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def scalar_add(self, other: Numeric) -> \"Money\":\n        return self",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "subtract",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def subtract(self, other: \"Money\") -> \"Money\":\n        return -other",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "scalar_subtract",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def scalar_subtract(self, other: Numeric) -> \"Money\":\n        return self",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "multiply",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def multiply(self, other: Numeric) -> \"Money\":\n        return self",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "divide",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def divide(self, other: Numeric) -> \"Money\":\n        return self",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "floor_divide",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def floor_divide(self, other: Numeric) -> \"Money\":\n        return self",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "lt",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def lt(self, other: \"Money\") -> bool:\n        return other.defined",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "lte",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def lte(self, other: \"Money\") -> bool:\n        return True",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "gt",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def gt(self, other: \"Money\") -> bool:\n        return False",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "gte",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def gte(self, other: \"Money\") -> bool:\n        return other.undefined",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "with_ccy",
        "docstring": null,
        "args": [
            "self",
            "ccy"
        ],
        "defaults": [],
        "code": "    def with_ccy(self, ccy: Currency) -> \"Money\":\n        return self",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "with_qty",
        "docstring": null,
        "args": [
            "self",
            "qty"
        ],
        "defaults": [],
        "code": "    def with_qty(self, qty: Decimal) -> \"Money\":\n        return self",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "with_dov",
        "docstring": null,
        "args": [
            "self",
            "dov"
        ],
        "defaults": [],
        "code": "    def with_dov(self, dov: Date) -> \"Money\":\n        return self",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "convert",
        "docstring": null,
        "args": [
            "self",
            "to",
            "asof",
            "strict"
        ],
        "defaults": [
            "None",
            "False"
        ],
        "code": "    def convert(self, to: Currency, asof: Optional[Date] = None, strict: bool = False) -> \"Money\":\n        return self",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "price",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def price(self) -> \"Price\":\n        return NoPrice",
        "class": "NoneMoney",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "is_equal",
        "docstring": "Checks the equality of two price objects.\n\nIn particular:\n\n1. ``True`` if ``other`` is a price object **and** all slots are same.\n2. ``False`` otherwise.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def is_equal(self, other: Any) -> bool:\n        \"\"\"\n        Checks the equality of two price objects.\n\n        In particular:\n\n        1. ``True`` if ``other`` is a price object **and** all slots are same.\n        2. ``False`` otherwise.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "as_boolean",
        "docstring": "Returns the logical representation of the price object.\n\nIn particular:\n\n1. ``False`` if price is *undefined* **or** price quantity is ``zero``.\n2. ``True`` otherwise.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def as_boolean(self) -> bool:\n        \"\"\"\n        Returns the logical representation of the price object.\n\n        In particular:\n\n        1. ``False`` if price is *undefined* **or** price quantity is ``zero``.\n        2. ``True`` otherwise.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "as_float",
        "docstring": "Returns the quantity as a ``float`` if *defined*, raises class:`MonetaryOperationException` otherwise.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def as_float(self) -> float:\n        \"\"\"\n        Returns the quantity as a ``float`` if *defined*, raises class:`MonetaryOperationException` otherwise.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "as_integer",
        "docstring": "Returns the quantity as an ``int`` if *defined*, raises class:`MonetaryOperationException` otherwise.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def as_integer(self) -> int:\n        \"\"\"\n        Returns the quantity as an ``int`` if *defined*, raises class:`MonetaryOperationException` otherwise.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "abs",
        "docstring": "Returns the absolute price if *defined*, itself otherwise.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def abs(self) -> \"Price\":\n        \"\"\"\n        Returns the absolute price if *defined*, itself otherwise.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "negative",
        "docstring": "Negates the quantity of the monetary value if *defined*, itself otherwise.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def negative(self) -> \"Price\":\n        \"\"\"\n        Negates the quantity of the monetary value if *defined*, itself otherwise.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "positive",
        "docstring": "Returns same monetary value if *defined*, itself otherwise.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def positive(self) -> \"Price\":\n        \"\"\"\n        Returns same monetary value if *defined*, itself otherwise.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "round",
        "docstring": "Rounds the quantity of the monetary value to ``ndigits`` by using ``HALF_EVEN`` method if *defined*, itself\notherwise.",
        "args": [
            "self",
            "ndigits"
        ],
        "defaults": [
            "0"
        ],
        "code": "    def round(self, ndigits: int = 0) -> \"Price\":\n        \"\"\"\n        Rounds the quantity of the monetary value to ``ndigits`` by using ``HALF_EVEN`` method if *defined*, itself\n        otherwise.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "add",
        "docstring": "Performs monetary addition on the price object and the given ``other`` price object.\n\nNote that::\n\n1. Raises :class:`IncompatibleCurrencyError` if currencies do not match.\n2. If any of the operands are undefined, returns the other one conveniently.\n3. Dates are carried forward as a result of addition of two defined price objects.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def add(self, other: \"Price\") -> \"Price\":\n        \"\"\"\n        Performs monetary addition on the price object and the given ``other`` price object.\n\n        Note that::\n\n        1. Raises :class:`IncompatibleCurrencyError` if currencies do not match.\n        2. If any of the operands are undefined, returns the other one conveniently.\n        3. Dates are carried forward as a result of addition of two defined price objects.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "scalar_add",
        "docstring": "Performs scalar addition on the quantity of the price.\n\nNote that undefined price object is returned as is.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def scalar_add(self, other: Numeric) -> \"Price\":\n        \"\"\"\n        Performs scalar addition on the quantity of the price.\n\n        Note that undefined price object is returned as is.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "subtract",
        "docstring": "Performs monetary subtraction on the price object and the given ``other`` price object.\n\nNote that::\n\n1. Raises :class:`IncompatibleCurrencyError` if currencies do not match.\n2. If any of the operands are undefined, returns the other one conveniently.\n3. Dates are carried forward as a result of addition of two defined price objects.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def subtract(self, other: \"Price\") -> \"Price\":\n        \"\"\"\n        Performs monetary subtraction on the price object and the given ``other`` price object.\n\n        Note that::\n\n        1. Raises :class:`IncompatibleCurrencyError` if currencies do not match.\n        2. If any of the operands are undefined, returns the other one conveniently.\n        3. Dates are carried forward as a result of addition of two defined price objects.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "scalar_subtract",
        "docstring": "Performs scalar subtraction on the quantity of the price.\n\nNote that undefined price object is returned as is.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def scalar_subtract(self, other: Numeric) -> \"Price\":\n        \"\"\"\n        Performs scalar subtraction on the quantity of the price.\n\n        Note that undefined price object is returned as is.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "multiply",
        "docstring": "Performs scalar multiplication.\n\nNote that undefined price object is returned as is.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def multiply(self, other: Numeric) -> \"Price\":\n        \"\"\"\n        Performs scalar multiplication.\n\n        Note that undefined price object is returned as is.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "times",
        "docstring": "Performs monetary multiplication operation.\n\nNote that undefined price object is returned as is.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def times(self, other: Numeric) -> \"Money\":\n        \"\"\"\n        Performs monetary multiplication operation.\n\n        Note that undefined price object is returned as is.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "divide",
        "docstring": "Performs ordinary division on the price object if *defined*, itself otherwise.\n\nNote that division by zero yields an undefined price object.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def divide(self, other: Numeric) -> \"Price\":\n        \"\"\"\n        Performs ordinary division on the price object if *defined*, itself otherwise.\n\n        Note that division by zero yields an undefined price object.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "floor_divide",
        "docstring": "Performs floor division on the price object if *defined*, itself otherwise.\n\nNote that division by zero yields an undefined price object.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def floor_divide(self, other: Numeric) -> \"Price\":\n        \"\"\"\n        Performs floor division on the price object if *defined*, itself otherwise.\n\n        Note that division by zero yields an undefined price object.\n\n        \"\"\"\n        raise NotImplementedError",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "lt",
        "docstring": "Applies \"less than\" comparison against ``other`` price.\n\nNote that::\n\n1. Undefined price objects are always less than ``other`` if ``other`` is not undefined, and\n2. :class:`IncompatibleCurrencyError` is raised when comparing two defined price objects with different\ncurrencies.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def lt(self, other: \"Price\") -> bool:\n        \"\"\"\n        Applies \"less than\" comparison against ``other`` price.\n\n        Note that::\n\n        1. Undefined price objects are always less than ``other`` if ``other`` is not undefined, and\n        2. :class:`IncompatibleCurrencyError` is raised when comparing two defined price objects with different\n        currencies.\n        \"\"\"\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "lte",
        "docstring": "Applies \"less than or equal to\" comparison against ``other`` price.\n\nNote that::\n\n1. Undefined price objects are always less than or equal to ``other``, and\n2. :class:`IncompatibleCurrencyError` is raised when comparing two defined price objects with different\ncurrencies.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def lte(self, other: \"Price\") -> bool:\n        \"\"\"\n        Applies \"less than or equal to\" comparison against ``other`` price.\n\n        Note that::\n\n        1. Undefined price objects are always less than or equal to ``other``, and\n        2. :class:`IncompatibleCurrencyError` is raised when comparing two defined price objects with different\n        currencies.\n        \"\"\"\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "gt",
        "docstring": "Applies \"greater than\" comparison against ``other`` price.\n\nNote that::\n\n1. Undefined price objects are never greater than ``other``,\n2. Defined price objects are always greater than ``other`` if other is undefined, and\n3. :class:`IncompatibleCurrencyError` is raised when comparing two defined price objects with different\ncurrencies.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def gt(self, other: \"Price\") -> bool:\n        \"\"\"\n        Applies \"greater than\" comparison against ``other`` price.\n\n        Note that::\n\n        1. Undefined price objects are never greater than ``other``,\n        2. Defined price objects are always greater than ``other`` if other is undefined, and\n        3. :class:`IncompatibleCurrencyError` is raised when comparing two defined price objects with different\n        currencies.\n        \"\"\"\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "gte",
        "docstring": "Applies \"greater than or equal to\" comparison against ``other`` price.\n\nNote that::\n\n1. Undefined price objects are never greater than or equal to ``other`` if ``other`` is defined,\n2. Undefined price objects are greater than or equal to ``other`` if ``other is undefined, and\n3. :class:`IncompatibleCurrencyError` is raised when comparing two defined price objects with different\ncurrencies.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def gte(self, other: \"Price\") -> bool:\n        \"\"\"\n        Applies \"greater than or equal to\" comparison against ``other`` price.\n\n        Note that::\n\n        1. Undefined price objects are never greater than or equal to ``other`` if ``other`` is defined,\n        2. Undefined price objects are greater than or equal to ``other`` if ``other is undefined, and\n        3. :class:`IncompatibleCurrencyError` is raised when comparing two defined price objects with different\n        currencies.\n        \"\"\"\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "with_ccy",
        "docstring": "Creates a new price object with the given currency if price is *defined*, returns itself otherwise.",
        "args": [
            "self",
            "ccy"
        ],
        "defaults": [],
        "code": "    def with_ccy(self, ccy: Currency) -> \"Price\":\n        \"\"\"\n        Creates a new price object with the given currency if price is *defined*, returns itself otherwise.\n        \"\"\"\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "with_qty",
        "docstring": "Creates a new price object with the given quantity if price is *defined*, returns itself otherwise.",
        "args": [
            "self",
            "qty"
        ],
        "defaults": [],
        "code": "    def with_qty(self, qty: Decimal) -> \"Price\":\n        \"\"\"\n        Creates a new price object with the given quantity if price is *defined*, returns itself otherwise.\n        \"\"\"\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "with_dov",
        "docstring": "Creates a new price object with the given value date if price is *defined*, returns itself otherwise.",
        "args": [
            "self",
            "dov"
        ],
        "defaults": [],
        "code": "    def with_dov(self, dov: Date) -> \"Price\":\n        \"\"\"\n        Creates a new price object with the given value date if price is *defined*, returns itself otherwise.\n        \"\"\"\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "convert",
        "docstring": "Converts the monetary value from one currency to another.\n\nRaises :class:`FXRateLookupError` if no foreign exchange rate can be found for conversion.\n\nNote that we will carry the date forward as per ``asof`` date.",
        "args": [
            "self",
            "to",
            "asof",
            "strict"
        ],
        "defaults": [
            "None",
            "False"
        ],
        "code": "    def convert(self, to: Currency, asof: Optional[Date] = None, strict: bool = False) -> \"Price\":\n        \"\"\"\n        Converts the monetary value from one currency to another.\n\n        Raises :class:`FXRateLookupError` if no foreign exchange rate can be found for conversion.\n\n        Note that we will carry the date forward as per ``asof`` date.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "money",
        "docstring": "Returns the money representation of the price object.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def money(self) -> Money:\n        \"\"\"\n        Returns the money representation of the price object.\n        \"\"\"\n        raise NotImplementedError",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "of",
        "docstring": "Provides a factory method to create a new price object in a safe manner.",
        "args": [
            "cls",
            "ccy",
            "qty",
            "dov"
        ],
        "defaults": [],
        "code": "    def of(cls, ccy: Optional[Currency], qty: Optional[Decimal], dov: Optional[Date]) -> \"Price\":\n        \"\"\"\n        Provides a factory method to create a new price object in a safe manner.\n        \"\"\"\n        if qty is None or ccy is None or dov is None:\n            return NoPrice\n        return SomePrice(ccy, qty, dov)",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__bool__",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __bool__(self) -> bool:\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__eq__",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __eq__(self, other: Any) -> bool:\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__abs__",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __abs__(self) -> \"Price\":\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__float__",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __float__(self) -> float:\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__int__",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __int__(self) -> int:\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__round__",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __round__(self) -> int:\n        ...",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__round__",
        "docstring": null,
        "args": [
            "self",
            "ndigits"
        ],
        "defaults": [],
        "code": "    def __round__(self, ndigits: None) -> int:\n        ...",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__round__",
        "docstring": null,
        "args": [
            "self",
            "ndigits"
        ],
        "defaults": [],
        "code": "    def __round__(self, ndigits: int) -> \"Price\":\n        ...",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__round__",
        "docstring": null,
        "args": [
            "self",
            "ndigits"
        ],
        "defaults": [
            "0"
        ],
        "code": "    def __round__(self, ndigits: Optional[int] = 0) -> Union[\"Price\", int]:\n        return self.round(ndigits or 0)",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__neg__",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __neg__(self) -> \"Price\":\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__pos__",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __pos__(self) -> \"Price\":\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__add__",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __add__(self, other: \"Price\") -> \"Price\":\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__sub__",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __sub__(self, other: \"Price\") -> \"Price\":\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__mul__",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __mul__(self, other: Numeric) -> \"Price\":\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__truediv__",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __truediv__(self, other: Numeric) -> \"Price\":\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__floordiv__",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __floordiv__(self, other: Numeric) -> \"Price\":\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__lt__",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __lt__(self, other: \"Price\") -> bool:\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__le__",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __le__(self, other: \"Price\") -> bool:\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__gt__",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __gt__(self, other: \"Price\") -> bool:\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "__ge__",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __ge__(self, other: \"Price\") -> bool:\n        pass",
        "class": "Price",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "is_equal",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def is_equal(self, other: Any) -> bool:\n        return other.__class__ is SomePrice and tuple(self) == tuple(other)",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "as_boolean",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def as_boolean(self) -> bool:\n        return self.qty.__bool__()",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "as_float",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def as_float(self) -> float:\n        return self.qty.__float__()",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "as_integer",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def as_integer(self) -> int:\n        return self.qty.__int__()",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "abs",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def abs(self) -> \"Price\":\n        c, q, d = self\n        return SomePrice(c, q.__abs__(), d)",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "negative",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def negative(self) -> \"Price\":\n        c, q, d = self\n        return SomePrice(c, q.__neg__(), d)",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "positive",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def positive(self) -> \"Price\":\n        c, q, d = self\n        return SomePrice(c, q.__pos__(), d)",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "round",
        "docstring": null,
        "args": [
            "self",
            "ndigits"
        ],
        "defaults": [
            "0"
        ],
        "code": "    def round(self, ndigits: int = 0) -> \"Price\":\n        c, q, d = self\n        return SomePrice(c, q.__round__(ndigits), d)",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "add",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def add(self, other: \"Price\") -> \"Price\":\n        if other.undefined:\n            return self\n\n        c1: Currency\n        q1: Decimal\n        d1: Date\n        c2: Currency\n        q2: Decimal\n        d2: Date\n        c1, q1, d1 = self\n        c2, q2, d2 = other  # type: ignore\n\n        if c1 != c2:\n            raise IncompatibleCurrencyError(ccy1=c1, ccy2=c2, operation=\"addition\")\n\n        return SomePrice(c1, q1 + q2, d1 if d1 > d2 else d2)",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "scalar_add",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def scalar_add(self, other: Numeric) -> \"Price\":\n        ## TODO: **try** not casting other to Decimal.\n        c, q, d = self\n        return SomePrice(c, q + Decimal(other), d)",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "subtract",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def subtract(self, other: \"Price\") -> \"Price\":\n        if other.undefined:\n            return self\n\n        c1: Currency\n        q1: Decimal\n        d1: Date\n        c2: Currency\n        q2: Decimal\n        d2: Date\n        c1, q1, d1 = self\n        c2, q2, d2 = other  # type: ignore\n\n        if c1 != c2:\n            raise IncompatibleCurrencyError(ccy1=c1, ccy2=c2, operation=\"subtraction\")\n\n        return SomePrice(c1, q1 - q2, d1 if d1 > d2 else d2)",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "scalar_subtract",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def scalar_subtract(self, other: Numeric) -> \"Price\":\n        ## TODO: **try** not casting other to Decimal.\n        c, q, d = self\n        return SomePrice(c, q - Decimal(other), d)",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "multiply",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def multiply(self, other: Numeric) -> \"Price\":\n        ## TODO: **try** not casting other to Decimal.\n        c, q, d = self\n        return SomePrice(c, q * Decimal(other), d)",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "times",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def times(self, other: Numeric) -> \"Money\":\n        c, q, d = self\n        return SomeMoney(c, (q * Decimal(other)).quantize(c.quantizer), self.dov)",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "divide",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def divide(self, other: Numeric) -> \"Price\":\n        ## TODO: **try** not casting other to Decimal.\n        try:\n            c, q, d = self\n            return SomePrice(c, q / Decimal(other), d)\n        except (InvalidOperation, DivisionByZero):\n            return NoPrice",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "floor_divide",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def floor_divide(self, other: Numeric) -> \"Price\":\n        ## TODO: **try** not casting other to Decimal.\n        try:\n            c, q, d = self\n            return SomePrice(c, q // Decimal(other), d)\n        except (InvalidOperation, DivisionByZero):\n            return NoPrice",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "lt",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def lt(self, other: \"Price\") -> bool:\n        if other.undefined:\n            return False\n        elif self.ccy != other.ccy:\n            raise IncompatibleCurrencyError(ccy1=self.ccy, ccy2=other.ccy, operation=\"< comparision\")\n        return self.qty < other.qty",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "lte",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def lte(self, other: \"Price\") -> bool:\n        if other.undefined:\n            return False\n        elif self.ccy != other.ccy:\n            raise IncompatibleCurrencyError(ccy1=self.ccy, ccy2=other.ccy, operation=\"<= comparision\")\n        return self.qty <= other.qty",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "gt",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def gt(self, other: \"Price\") -> bool:\n        if other.undefined:\n            return True\n        elif self.ccy != other.ccy:\n            raise IncompatibleCurrencyError(ccy1=self.ccy, ccy2=other.ccy, operation=\"> comparision\")\n        return self.qty > other.qty",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "gte",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def gte(self, other: \"Price\") -> bool:\n        if other.undefined:\n            return True\n        elif self.ccy != other.ccy:\n            raise IncompatibleCurrencyError(ccy1=self.ccy, ccy2=other.ccy, operation=\">= comparision\")\n        return self.qty >= other.qty",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "with_ccy",
        "docstring": null,
        "args": [
            "self",
            "ccy"
        ],
        "defaults": [],
        "code": "    def with_ccy(self, ccy: Currency) -> \"Price\":\n        return SomePrice(ccy, self[1], self[2])",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "with_qty",
        "docstring": null,
        "args": [
            "self",
            "qty"
        ],
        "defaults": [],
        "code": "    def with_qty(self, qty: Decimal) -> \"Price\":\n        return SomePrice(self[0], qty, self[2])",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "with_dov",
        "docstring": null,
        "args": [
            "self",
            "dov"
        ],
        "defaults": [],
        "code": "    def with_dov(self, dov: Date) -> \"Price\":\n        return SomePrice(self[0], self[1], dov)",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "convert",
        "docstring": null,
        "args": [
            "self",
            "to",
            "asof",
            "strict"
        ],
        "defaults": [
            "None",
            "False"
        ],
        "code": "    def convert(self, to: Currency, asof: Optional[Date] = None, strict: bool = False) -> \"Price\":\n        ## Get slots:\n        ccy, qty, dov = self\n\n        ## Get date of conversion:\n        asof = asof or dov\n\n        ## Attempt to get the FX rate:\n        try:\n            rate = FXRateService.default.query(ccy, to, asof, strict)  # type: ignore\n        except AttributeError as exc:\n            if FXRateService.default is None:\n                raise ProgrammingError(\"Did you implement and set the default FX rate service?\")\n            else:\n                raise exc\n\n        ## Do we have a rate?\n        if rate is None:\n            ## Nope, shall we raise exception?\n            if strict:\n                ## Yep:\n                raise FXRateLookupError(ccy, to, asof)\n            else:\n                ## Just return NA:\n                return NoPrice\n\n        ## Compute and return:\n        return SomePrice(to, qty * rate.value, asof)",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "money",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def money(self) -> Money:\n        c, q, d = self\n        return SomeMoney(c, q.quantize(c.quantizer), d)",
        "class": "SomePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "as_boolean",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def as_boolean(self) -> bool:\n        return False",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "is_equal",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def is_equal(self, other: Any) -> bool:\n        return other.__class__ is NonePrice",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "abs",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def abs(self) -> \"Price\":\n        return self",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "as_float",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def as_float(self) -> float:\n        raise TypeError(\"Undefined monetary values do not have quantity information.\")",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "as_integer",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def as_integer(self) -> int:\n        raise TypeError(\"Undefined monetary values do not have quantity information.\")",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "round",
        "docstring": null,
        "args": [
            "self",
            "ndigits"
        ],
        "defaults": [
            "0"
        ],
        "code": "    def round(self, ndigits: int = 0) -> \"Price\":\n        return self",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "negative",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def negative(self) -> \"Price\":\n        return self",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "positive",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def positive(self) -> \"Price\":\n        return self",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "add",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def add(self, other: \"Price\") -> \"Price\":\n        return other",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "scalar_add",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def scalar_add(self, other: Numeric) -> \"Price\":\n        return self",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "subtract",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def subtract(self, other: \"Price\") -> \"Price\":\n        return -other",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "scalar_subtract",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def scalar_subtract(self, other: Numeric) -> \"Price\":\n        return self",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "multiply",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def multiply(self, other: Numeric) -> \"Price\":\n        return self",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "times",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def times(self, other: Numeric) -> \"Money\":\n        return NoMoney",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "divide",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def divide(self, other: Numeric) -> \"Price\":\n        return self",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "floor_divide",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def floor_divide(self, other: Numeric) -> \"Price\":\n        return self",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "lt",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def lt(self, other: \"Price\") -> bool:\n        return other.defined",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "lte",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def lte(self, other: \"Price\") -> bool:\n        return True",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "gt",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def gt(self, other: \"Price\") -> bool:\n        return False",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "gte",
        "docstring": null,
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def gte(self, other: \"Price\") -> bool:\n        return other.undefined",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "with_ccy",
        "docstring": null,
        "args": [
            "self",
            "ccy"
        ],
        "defaults": [],
        "code": "    def with_ccy(self, ccy: Currency) -> \"Price\":\n        return self",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "with_qty",
        "docstring": null,
        "args": [
            "self",
            "qty"
        ],
        "defaults": [],
        "code": "    def with_qty(self, qty: Decimal) -> \"Price\":\n        return self",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "with_dov",
        "docstring": null,
        "args": [
            "self",
            "dov"
        ],
        "defaults": [],
        "code": "    def with_dov(self, dov: Date) -> \"Price\":\n        return self",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "convert",
        "docstring": null,
        "args": [
            "self",
            "to",
            "asof",
            "strict"
        ],
        "defaults": [
            "None",
            "False"
        ],
        "code": "    def convert(self, to: Currency, asof: Optional[Date] = None, strict: bool = False) -> \"Price\":\n        return self",
        "class": "NonePrice",
        "file": "input/pypara/monetary.py"
    },
    {
        "name": "_as_ccys",
        "docstring": "Converts a set of currency codes to a set of currencies.",
        "args": [
            "codes"
        ],
        "defaults": [],
        "code": "def _as_ccys(codes: Set[str]) -> Set[Currency]:\n    \"\"\"\n    Converts a set of currency codes to a set of currencies.\n    \"\"\"\n    return {Currencies[c] for c in codes}",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "_get_date_range",
        "docstring": "Returns a generator of dates falling into range within the given period (``end`` is exclusive).\n\n:param start: The start date of the period.\n:param end: The end date of the period.\n:return: A generator of dates.",
        "args": [
            "start",
            "end"
        ],
        "defaults": [],
        "code": "def _get_date_range(start: Date, end: Date) -> Iterable[Date]:\n    \"\"\"\n    Returns a generator of dates falling into range within the given period (``end`` is exclusive).\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: A generator of dates.\n    \"\"\"\n    for i in range((end - start).days):\n        yield start + datetime.timedelta(days=i)",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "_get_actual_day_count",
        "docstring": "Counts the actual number of days in the given period.\n\n:param start: The start date of the period.\n:param end: The end date of the period.\n:return: The number of days in the given period.\n\n>>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 1))\n0\n>>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 2))\n1",
        "args": [
            "start",
            "end"
        ],
        "defaults": [],
        "code": "def _get_actual_day_count(start: Date, end: Date) -> int:\n    \"\"\"\n    Counts the actual number of days in the given period.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: The number of days in the given period.\n\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 1))\n    0\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 2))\n    1\n    \"\"\"\n    return (end - start).days",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "_has_leap_day",
        "docstring": "Indicates if the range has any leap day.",
        "args": [
            "start",
            "end"
        ],
        "defaults": [],
        "code": "def _has_leap_day(start: Date, end: Date) -> bool:\n    \"\"\"\n    Indicates if the range has any leap day.\n    \"\"\"\n    ## Get all leap years:\n    years = {year for year in range(start.year, end.year + 1) if calendar.isleap(year)}\n\n    ## Check if any of the lap day falls in our range:\n    for year in years:\n        ## Construct the leap day:\n        leapday = datetime.date(year, 2, 29)\n\n        ## Is the leap date in the range?\n        if start <= leapday <= end:\n            ## Yes, the leap day is within the date range. Return True:\n            return True\n\n    ## No leap day in the range, return False:\n    return False",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "_is_last_day_of_month",
        "docstring": "Indicates if the date is the last day of the month.",
        "args": [
            "date"
        ],
        "defaults": [],
        "code": "def _is_last_day_of_month(date: Date) -> bool:\n    \"\"\"\n    Indicates if the date is the last day of the month.\n    \"\"\"\n    return date.day == calendar.monthrange(date.year, date.month)[1]",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "_last_payment_date",
        "docstring": "Returns the last coupon payment date.\n\n>>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\ndatetime.date(2015, 1, 1)\n\n>>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\ndatetime.date(2015, 1, 1)\n\n>>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\ndatetime.date(2015, 7, 1)\n\n>>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\ndatetime.date(2015, 7, 1)\n\n>>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\ndatetime.date(2015, 1, 1)\n\n>>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\ndatetime.date(2014, 6, 1)\n\n>>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\ndatetime.date(2015, 7, 7)\n\n>>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\ndatetime.date(2014, 12, 9)\n\n>>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\ndatetime.date(2015, 12, 15)\n\n>>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\ndatetime.date(2015, 12, 15)",
        "args": [
            "start",
            "asof",
            "frequency",
            "eom"
        ],
        "defaults": [
            "None"
        ],
        "code": "def _last_payment_date(start: Date, asof: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n    ## Make sure that we have eom:\n    eom = eom or start.day\n\n    ## Get the starting month:\n    s_month = start.month\n\n    ## Get the period:\n    period = int(12 / frequency)\n\n    ## Get the current day, month and year:\n    c_day, c_month, c_year = asof.day, asof.month, asof.year\n\n    ## Get the payment schedule:\n    schedule = sorted([i > 0 and i or 12 for i in sorted([(i + s_month) % 12 for i in range(0, 12, period)])])\n\n    ## Filter out previous:\n    future = [month for month in schedule if (month < c_month) or (month == c_month and eom <= c_day)]\n\n    ## Get the previous month and year:\n    p_year, p_month = (c_year, future[-1]) if future else (c_year - 1, schedule[-1])\n\n    ## Return the date:\n    if p_year < 1 or p_month < 1 or eom < 1:\n        return start\n\n    ## Construct and return the date safely:\n    return _construct_date(p_year, p_month, eom)",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "_next_payment_date",
        "docstring": "Returns the last coupon payment date.\n\n>>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\ndatetime.date(2015, 1, 1)\n\n>>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\ndatetime.date(2015, 1, 15)",
        "args": [
            "start",
            "frequency",
            "eom"
        ],
        "defaults": [
            "None"
        ],
        "code": "def _next_payment_date(start: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    ## Get the number of months to move forward:\n    months = int(12 / frequency)\n\n    ## Find the next date:\n    nextdate = start + relativedelta(months=months)\n\n    ## Do we have any end of month?\n    if eom:\n        try:\n            nextdate = nextdate.replace(day=eom)\n        except ValueError:\n            pass\n\n    ## Done, return:\n    return nextdate",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "_construct_date",
        "docstring": "Constructs and returns date safely.",
        "args": [
            "year",
            "month",
            "day"
        ],
        "defaults": [],
        "code": "def _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Constructs and returns date safely.\n    \"\"\"\n    if year <= 0 or month <= 0 or day <= 0:\n        raise ValueError(\"year, month and day must be greater than 0.\")\n    try:\n        return datetime.date(year, month, day)\n    except ValueError as exc:\n        if str(exc) == \"day is out of range for month\":\n            return _construct_date(year, month, day - 1)\n        else:\n            raise exc",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "calculate_fraction",
        "docstring": "Calculates the day count fraction based on the underlying methodology after performing some general checks.",
        "args": [
            "self",
            "start",
            "asof",
            "end",
            "freq"
        ],
        "defaults": [
            "None"
        ],
        "code": "    def calculate_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates the day count fraction based on the underlying methodology after performing some general checks.\n        \"\"\"\n        ## Checks if dates are provided properly:\n        if not start <= asof <= end:\n            ## Nope, return 0:\n            return ZERO\n\n        ## Cool, we can proceed with calculation based on the methodology:\n        return self[3](start, asof, end, freq)",
        "class": "DCC",
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "calculate_daily_fraction",
        "docstring": "Calculates daily fraction.",
        "args": [
            "self",
            "start",
            "asof",
            "end",
            "freq"
        ],
        "defaults": [
            "None"
        ],
        "code": "    def calculate_daily_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates daily fraction.\n        \"\"\"\n        ## Get t-1 for asof:\n        asof_minus_1 = asof - datetime.timedelta(days=1)\n\n        ## Get the yesterday's factor:\n        if asof_minus_1 < start:\n            yfact = ZERO\n        else:\n            yfact = self.calculate_fraction_method(start, asof_minus_1, end, freq)\n\n        ## Get today's factor:\n        tfact = self.calculate_fraction_method(start, asof, end, freq)\n\n        ## Get the factor and return:\n        return tfact - yfact",
        "class": "DCC",
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "interest",
        "docstring": "Calculates the accrued interest.",
        "args": [
            "self",
            "principal",
            "rate",
            "start",
            "asof",
            "end",
            "freq"
        ],
        "defaults": [
            "None",
            "None"
        ],
        "code": "    def interest(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Optional[Date] = None,\n        freq: Optional[Decimal] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest.\n        \"\"\"\n        return principal * rate * self.calculate_fraction(start, asof, end or asof, freq)",
        "class": "DCC",
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "coupon",
        "docstring": "Calculates the accrued interest for the coupon payment.\n\nThis method is primarily used for bond coupon accruals which assumes the start date to be the first of regular\npayment schedules.",
        "args": [
            "self",
            "principal",
            "rate",
            "start",
            "asof",
            "end",
            "freq",
            "eom"
        ],
        "defaults": [
            "None"
        ],
        "code": "    def coupon(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Date,\n        freq: Union[int, Decimal],\n        eom: Optional[int] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest for the coupon payment.\n\n        This method is primarily used for bond coupon accruals which assumes the start date to be the first of regular\n        payment schedules.\n        \"\"\"\n        ## Find the previous and next payment dates:\n        prevdate = _last_payment_date(start, asof, freq, eom)\n        nextdate = _next_payment_date(prevdate, freq, eom)\n\n        ## Calculate the interest and return:\n        return self.interest(principal, rate, prevdate, asof, nextdate, Decimal(freq))",
        "class": "DCC",
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "__init__",
        "docstring": "Initializes the registry.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __init__(self) -> None:\n        \"\"\"\n        Initializes the registry.\n        \"\"\"\n        ## Define the main registry buffer:\n        self._buffer_main: Dict[str, DCC] = {}\n\n        ## Defines the registry buffer for alternative DCC names:\n        self._buffer_altn: Dict[str, DCC] = {}",
        "class": "DCCRegistryMachinery",
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "_is_registered",
        "docstring": "Checks if the given name is ever registered before.",
        "args": [
            "self",
            "name"
        ],
        "defaults": [],
        "code": "    def _is_registered(self, name: str) -> bool:\n        \"\"\"\n        Checks if the given name is ever registered before.\n        \"\"\"\n        return name in self._buffer_main or name in self._buffer_altn",
        "class": "DCCRegistryMachinery",
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "register",
        "docstring": "Attempts to register the given day count convention.",
        "args": [
            "self",
            "dcc"
        ],
        "defaults": [],
        "code": "    def register(self, dcc: DCC) -> None:\n        \"\"\"\n        Attempts to register the given day count convention.\n        \"\"\"\n        ## Check if the main name is ever registered before:\n        if self._is_registered(dcc.name):\n            ## Yep, raise a TypeError:\n            raise TypeError(f\"Day count convention '{dcc.name}' is already registered\")\n\n        ## Add to the main buffer:\n        self._buffer_main[dcc.name] = dcc\n\n        ## Check if there is any registry conflict:\n        for name in dcc.altnames:\n            ## Check if the name is ever registered:\n            if self._is_registered(name):\n                ## Yep, raise a TypeError:\n                raise TypeError(f\"Day count convention '{dcc.name}' is already registered\")\n\n            ## Register to the alternative buffer:\n            self._buffer_altn[name] = dcc",
        "class": "DCCRegistryMachinery",
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "_find_strict",
        "docstring": "Attempts to find the day count convention by the given name.",
        "args": [
            "self",
            "name"
        ],
        "defaults": [],
        "code": "    def _find_strict(self, name: str) -> Optional[DCC]:\n        \"\"\"\n        Attempts to find the day count convention by the given name.\n        \"\"\"\n        return self._buffer_main.get(name) or self._buffer_altn.get(name)",
        "class": "DCCRegistryMachinery",
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "find",
        "docstring": "Attempts to find the day count convention by the given name.\n\nNote that all day count conventions are registered under stripped, uppercased names. Therefore,\nthe implementation will first attempt to find by given name as is. If it can not find it, it will\nstrip and uppercase the name and try to find it as such as a last resort.",
        "args": [
            "self",
            "name"
        ],
        "defaults": [],
        "code": "    def find(self, name: str) -> Optional[DCC]:\n        \"\"\"\n        Attempts to find the day count convention by the given name.\n\n        Note that all day count conventions are registered under stripped, uppercased names. Therefore,\n        the implementation will first attempt to find by given name as is. If it can not find it, it will\n        strip and uppercase the name and try to find it as such as a last resort.\n        \"\"\"\n        return self._find_strict(name) or self._find_strict(name.strip().upper())",
        "class": "DCCRegistryMachinery",
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "registry",
        "docstring": "Returns the main registry values.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def registry(self) -> List[DCC]:\n        \"\"\"\n        Returns the main registry values.\n        \"\"\"\n        return list(self._buffer_main.values())",
        "class": "DCCRegistryMachinery",
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "table",
        "docstring": "Returns a lookup table for available day count conventions.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def table(self) -> Dict[str, DCC]:\n        \"\"\"\n        Returns a lookup table for available day count conventions.\n        \"\"\"\n        return {**{k: v for k, v in self._buffer_main.items()}, **{k: v for k, v in self._buffer_altn.items()}}",
        "class": "DCCRegistryMachinery",
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "dcc",
        "docstring": "Registers a day count fraction calculator under the given names and alternative names (if any).\n\n:param name: The name of the day count convention.\n:param altnames: A set of alternative names of the day count convention, if any.\n:param ccys: A set of currencies which are known to use this convention by default, if any.\n:return: Registered day count fraction calculation function.",
        "args": [
            "name",
            "altnames",
            "ccys"
        ],
        "defaults": [
            "None",
            "None"
        ],
        "code": "def dcc(name: str, altnames: Optional[Set[str]] = None, ccys: Optional[Set[Currency]] = None) -> Callable[[DCFC], DCFC]:\n    \"\"\"\n    Registers a day count fraction calculator under the given names and alternative names (if any).\n\n    :param name: The name of the day count convention.\n    :param altnames: A set of alternative names of the day count convention, if any.\n    :param ccys: A set of currencies which are known to use this convention by default, if any.\n    :return: Registered day count fraction calculation function.\n    \"\"\"\n\n    def register_and_return_dcfc(func: DCFC) -> DCFC:\n        \"\"\"\n        Registers the given day count fraction calculator and returns it.\n\n        :param func: Day count fraction calculation function to be registered.\n        :return: Registered day count fraction calculation function.\n        \"\"\"\n        ## Create the DCC instance:\n        dcc = DCC(name, altnames or set([]), ccys or set([]), func)\n\n        ## Attempt to register the DCC:\n        DCCRegistry.register(dcc)\n\n        ## Attach the dcc instance to the day count fraction calculation function (for whatever it is worth):\n        setattr(func, \"__dcc\", dcc)\n\n        ## Done, return the function (if above statment did not raise any exceptions):\n        return func\n\n    return register_and_return_dcfc",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "register_and_return_dcfc",
        "docstring": "Registers the given day count fraction calculator and returns it.\n\n:param func: Day count fraction calculation function to be registered.\n:return: Registered day count fraction calculation function.",
        "args": [
            "func"
        ],
        "defaults": [],
        "code": "    def register_and_return_dcfc(func: DCFC) -> DCFC:\n        \"\"\"\n        Registers the given day count fraction calculator and returns it.\n\n        :param func: Day count fraction calculation function to be registered.\n        :return: Registered day count fraction calculation function.\n        \"\"\"\n        ## Create the DCC instance:\n        dcc = DCC(name, altnames or set([]), ccys or set([]), func)\n\n        ## Attempt to register the DCC:\n        DCCRegistry.register(dcc)\n\n        ## Attach the dcc instance to the day count fraction calculation function (for whatever it is worth):\n        setattr(func, \"__dcc\", dcc)\n\n        ## Done, return the function (if above statment did not raise any exceptions):\n        return func",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "dcfc_act_act",
        "docstring": "Computes the day count fraction for \"Act/Act\" convention.\n\n:param start: The start date of the period.\n:param asof: The date which the day count fraction to be calculated as of.\n:param end: The end date of the period (a.k.a. termination date).\n:param freq: The frequency of payments in a year.\n:return: Day count fraction.\n\n>>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n>>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n>>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n>>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n>>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\nDecimal('0.16942884946478')\n>>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\nDecimal('0.17216108990194')\n>>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\nDecimal('1.08243131970956')\n>>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\nDecimal('1.32625945055768')",
        "args": [
            "start",
            "asof",
            "end",
            "freq"
        ],
        "defaults": [
            "None"
        ],
        "code": "def dcfc_act_act(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n    ## Get all years of interest by checking the leap year:\n    years = {year: calendar.isleap(year) for year in range(start.year, asof.year + 1)}\n\n    ## Define the buffer of days for the day count. The former is for non-leap years, the latter for leap years:\n    buffer: List[int] = [0, 0]\n\n    ## Iterate over the date range and count:\n    for date in _get_date_range(start, asof):\n        ## Check the year and modify buffer accordingly:\n        if years[date.year]:\n            ## Yep, it is a leap year:\n            buffer[1] += 1\n        else:\n            ## Nope, not a leap year:\n            buffer[0] += 1\n\n    ## Done, compute and return:\n    return Decimal(buffer[0]) / Decimal(365) + Decimal(buffer[1]) / Decimal(366)",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "dcfc_act_act_icma",
        "docstring": "Computes the day count fraction for \"Act/Act (ICMA)\" convention.\n\n:param start: The start date of the period.\n:param asof: The date which the day count fraction to be calculated as of.\n:param end: The end date of the period (a.k.a. termination date).\n:return: Day count fraction.\n\n>>> ex1_start, ex1_asof, ex1_end = datetime.date(2019, 3, 2), datetime.date(2019, 9, 10), datetime.date(2020, 3, 2)\n>>> round(dcfc_act_act_icma(start=ex1_start, asof=ex1_asof, end=ex1_end), 10)\nDecimal('0.5245901639')",
        "args": [
            "start",
            "asof",
            "end",
            "freq"
        ],
        "defaults": [
            "None"
        ],
        "code": "def dcfc_act_act_icma(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act (ICMA)\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof, ex1_end = datetime.date(2019, 3, 2), datetime.date(2019, 9, 10), datetime.date(2020, 3, 2)\n    >>> round(dcfc_act_act_icma(start=ex1_start, asof=ex1_asof, end=ex1_end), 10)\n    Decimal('0.5245901639')\n    \"\"\"\n    ## Get the number of actual days:\n    p1 = Decimal(_get_actual_day_count(start, asof))\n\n    ## Get the number of days in the period:\n    p2 = Decimal(_get_actual_day_count(start, end))\n\n    ## Compute the ratio and return:\n    return p1 / p2 / Decimal(freq or ONE)",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "dcfc_act_360",
        "docstring": "Computes the day count fraction for \"Act/360\" convention.\n\n:param start: The start date of the period.\n:param end: The end date of the period.\n:return: Day count fraction.\n\n>>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n>>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n>>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n>>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n>>> round(dcfc_act_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\nDecimal('0.17222222222222')\n>>> round(dcfc_act_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\nDecimal('0.17500000000000')\n>>> round(dcfc_act_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\nDecimal('1.10000000000000')\n>>> round(dcfc_act_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\nDecimal('1.34722222222222')",
        "args": [
            "start",
            "asof",
            "end",
            "freq"
        ],
        "defaults": [
            "None"
        ],
        "code": "def dcfc_act_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/360\" convention.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.17222222222222')\n    >>> round(dcfc_act_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17500000000000')\n    >>> round(dcfc_act_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.10000000000000')\n    >>> round(dcfc_act_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.34722222222222')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(360)",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "dcfc_act_365_f",
        "docstring": "Computes the day count fraction for the \"Act/365F\" convention.\n\n:param start: The start date of the period.\n:param asof: The date which the day count fraction to be calculated as of.\n:param end: The end date of the period (a.k.a. termination date).\n:return: Day count fraction.\n\n>>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n>>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n>>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n>>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n>>> round(dcfc_act_365_f(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\nDecimal('0.16986301369863')\n>>> round(dcfc_act_365_f(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\nDecimal('0.17260273972603')\n>>> round(dcfc_act_365_f(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\nDecimal('1.08493150684932')\n>>> round(dcfc_act_365_f(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\nDecimal('1.32876712328767')",
        "args": [
            "start",
            "asof",
            "end",
            "freq"
        ],
        "defaults": [
            "None"
        ],
        "code": "def dcfc_act_365_f(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365F\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_f(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_f(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17260273972603')\n    >>> round(dcfc_act_365_f(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08493150684932')\n    >>> round(dcfc_act_365_f(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(365)",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "dcfc_act_365_a",
        "docstring": "Computes the day count fraction for the \"Act/365A\" convention.\n\n:param start: The start date of the period.\n:param asof: The date which the day count fraction to be calculated as of.\n:param end: The end date of the period (a.k.a. termination date).\n:return: Day count fraction.\n\n>>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n>>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n>>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n>>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n>>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\nDecimal('0.16986301369863')\n>>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\nDecimal('0.17213114754098')\n>>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\nDecimal('1.08196721311475')\n>>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\nDecimal('1.32513661202186')",
        "args": [
            "start",
            "asof",
            "end",
            "freq"
        ],
        "defaults": [
            "None"
        ],
        "code": "def dcfc_act_365_a(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365A\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32513661202186')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if _has_leap_day(start, asof) else 365)",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "dcfc_act_365_l",
        "docstring": "Computes the day count fraction for the \"Act/365L\" convention.\n\n:param start: The start date of the period.\n:param asof: The date which the day count fraction to be calculated as of.\n:param end: The end date of the period (a.k.a. termination date).\n:return: Day count fraction.\n\n>>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n>>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n>>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n>>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n>>> round(dcfc_act_365_l(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\nDecimal('0.16939890710383')\n>>> round(dcfc_act_365_l(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\nDecimal('0.17213114754098')\n>>> round(dcfc_act_365_l(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\nDecimal('1.08196721311475')\n>>> round(dcfc_act_365_l(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\nDecimal('1.32876712328767')",
        "args": [
            "start",
            "asof",
            "end",
            "freq"
        ],
        "defaults": [
            "None"
        ],
        "code": "def dcfc_act_365_l(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365L\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_l(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16939890710383')\n    >>> round(dcfc_act_365_l(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_l(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_l(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "dcfc_nl_365",
        "docstring": "Computes the day count fraction for the \"NL/365\" convention.\n\n:param start: The start date of the period.\n:param asof: The date which the day count fraction to be calculated as of.\n:param end: The end date of the period (a.k.a. termination date).\n:return: Day count fraction.\n\n>>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n>>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n>>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n>>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n>>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\nDecimal('0.16986301369863')\n>>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\nDecimal('0.16986301369863')\n>>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\nDecimal('1.08219178082192')\n>>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\nDecimal('1.32602739726027')",
        "args": [
            "start",
            "asof",
            "end",
            "freq"
        ],
        "defaults": [
            "None"
        ],
        "code": "def dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "dcfc_30_360_isda",
        "docstring": "Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n:param start: The start date of the period.\n:param asof: The date which the day count fraction to be calculated as of.\n:param end: The end date of the period (a.k.a. termination date).\n:return: Day count fraction.\n\n>>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n>>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n>>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n>>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n>>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\nDecimal('0.16666666666667')\n>>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\nDecimal('0.16944444444444')\n>>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\nDecimal('1.08333333333333')\n>>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\nDecimal('1.33333333333333')",
        "args": [
            "start",
            "asof",
            "end",
            "freq"
        ],
        "defaults": [
            "None"
        ],
        "code": "def dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "dcfc_30_e_360",
        "docstring": "Computes the day count fraction for the \"30E/360\" convention.\n\n:param start: The start date of the period.\n:param asof: The date which the day count fraction to be calculated as of.\n:param end: The end date of the period (a.k.a. termination date).\n:return: Day count fraction.\n\n>>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n>>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n>>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n>>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n>>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\nDecimal('0.16666666666667')\n>>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\nDecimal('0.16944444444444')\n>>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\nDecimal('1.08333333333333')\n>>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\nDecimal('1.33055555555556')",
        "args": [
            "start",
            "asof",
            "end",
            "freq"
        ],
        "defaults": [
            "None"
        ],
        "code": "def dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "dcfc_30_e_plus_360",
        "docstring": "Computes the day count fraction for the \"30E+/360\" convention.\n\n:param start: The start date of the period.\n:param asof: The date which the day count fraction to be calculated as of.\n:param end: The end date of the period (a.k.a. termination date).\n:return: Day count fraction.\n\n\n>>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n>>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n>>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n>>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n>>> round(dcfc_30_e_plus_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\nDecimal('0.16666666666667')\n>>> round(dcfc_30_e_plus_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\nDecimal('0.16944444444444')\n>>> round(dcfc_30_e_plus_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\nDecimal('1.08333333333333')\n>>> round(dcfc_30_e_plus_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\nDecimal('1.33333333333333')",
        "args": [
            "start",
            "asof",
            "end",
            "freq"
        ],
        "defaults": [
            "None"
        ],
        "code": "def dcfc_30_e_plus_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E+/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_plus_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_plus_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_plus_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_plus_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = asof + datetime.timedelta(days=1)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "dcfc_30_360_german",
        "docstring": "Computes the day count fraction.\n\n:param start: The start date of the period.\n:param asof: The date which the day count fraction to be calculated as of.\n:param end: The end date of the period (a.k.a. termination date).\n:return: Day count fraction.\n\n>>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n>>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n>>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n>>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n>>> round(dcfc_30_360_german(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\nDecimal('0.16666666666667')\n>>> round(dcfc_30_360_german(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\nDecimal('0.16944444444444')\n>>> round(dcfc_30_360_german(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\nDecimal('1.08333333333333')\n>>> round(dcfc_30_360_german(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\nDecimal('1.33055555555556')",
        "args": [
            "start",
            "asof",
            "end",
            "freq"
        ],
        "defaults": [
            "None"
        ],
        "code": "def dcfc_30_360_german(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_german(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_german(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_german(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_german(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31 or (start.month == 2 and _is_last_day_of_month(start)):\n        d1 = 30\n    else:\n        d1 = start.day\n\n    ## Get the new asof date, if required:\n    if asof.day == 31 or (asof.month == 2 and _is_last_day_of_month(asof) and end != asof):\n        d2 = 30\n    else:\n        d2 = asof.day\n\n    ## Compute number of days:\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "dcfc_30_360_us",
        "docstring": "Computes the day count fraction for the \"30/360 US\" convention.\n\n:param start: The start date of the period.\n:param asof: The date which the day count fraction to be calculated as of.\n:param end: The end date of the period (a.k.a. termination date).\n:return: Day count fraction.\n\n>>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n>>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n>>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n>>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n>>> round(dcfc_30_360_us(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\nDecimal('0.16666666666667')\n>>> round(dcfc_30_360_us(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\nDecimal('0.16944444444444')\n>>> round(dcfc_30_360_us(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\nDecimal('1.08333333333333')\n>>> round(dcfc_30_360_us(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\nDecimal('1.33333333333333')",
        "args": [
            "start",
            "asof",
            "end",
            "freq"
        ],
        "defaults": [
            "None"
        ],
        "code": "def dcfc_30_360_us(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 US\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_us(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_us(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_us(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_us(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get D1 and D2:\n    d1 = start.day\n    d2 = asof.day\n\n    ## Need to change D1?\n    if _is_last_day_of_month(start):\n        ## Yep, change it:\n        d1 = 30\n\n        ## Shall we change the d2, too?\n        if _is_last_day_of_month(asof):\n            d2 = 30\n\n    ## Revisit d2:\n    if d2 == 31 and (d1 == 30 or d1 == 31):\n        d2 = 30\n\n    ## Revisit d1:\n    if d1 == 31:\n        d1 = 30\n\n    ## Compute number of days:\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, return:\n    return nod / Decimal(360)",
        "class": null,
        "file": "input/pypara/dcc.py"
    },
    {
        "name": "__init__",
        "docstring": "Initializes the foreign exchange rate lookup error.",
        "args": [
            "self",
            "ccy1",
            "ccy2",
            "asof"
        ],
        "defaults": [],
        "code": "    def __init__(self, ccy1: Currency, ccy2: Currency, asof: Date) -> None:\n        \"\"\"\n        Initializes the foreign exchange rate lookup error.\n        \"\"\"\n        ## Keep the slots:\n        self.ccy1 = ccy1\n        self.ccy2 = ccy2\n        self.asof = asof\n\n        ## Set the message:\n        super().__init__(f\"Foreign exchange rate for {ccy1}/{ccy2} not found as of {asof}\")",
        "class": "FXRateLookupError",
        "file": "input/pypara/exchange.py"
    },
    {
        "name": "__invert__",
        "docstring": "Returns the inverted foreign exchange rate.\n\n>>> import datetime\n>>> from decimal import Decimal\n>>> from pypara.currencies import Currencies\n>>> nrate = FXRate(Currencies[\"EUR\"], Currencies[\"USD\"], datetime.date.today(), Decimal(\"2\"))\n>>> rrate = FXRate(Currencies[\"USD\"], Currencies[\"EUR\"], datetime.date.today(), Decimal(\"0.5\"))\n>>> ~nrate == rrate\nTrue",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __invert__(self) -> \"FXRate\":\n        \"\"\"\n        Returns the inverted foreign exchange rate.\n\n        >>> import datetime\n        >>> from decimal import Decimal\n        >>> from pypara.currencies import Currencies\n        >>> nrate = FXRate(Currencies[\"EUR\"], Currencies[\"USD\"], datetime.date.today(), Decimal(\"2\"))\n        >>> rrate = FXRate(Currencies[\"USD\"], Currencies[\"EUR\"], datetime.date.today(), Decimal(\"0.5\"))\n        >>> ~nrate == rrate\n        True\n        \"\"\"\n        return FXRate(self[1], self[0], self[2], self[3] ** -1)",
        "class": "FXRate",
        "file": "input/pypara/exchange.py"
    },
    {
        "name": "of",
        "docstring": "Creates and returns an FX rate instance by validating arguments.\n\n>>> import datetime\n>>> from decimal import Decimal\n>>> from pypara.currencies import Currencies\n>>> urate = FXRate(Currencies[\"EUR\"], Currencies[\"USD\"], datetime.date.today(), Decimal(\"2\"))\n>>> srate = FXRate.of(Currencies[\"EUR\"], Currencies[\"USD\"], datetime.date.today(), Decimal(\"2\"))\n>>> urate == srate\nTrue",
        "args": [
            "cls",
            "ccy1",
            "ccy2",
            "date",
            "value"
        ],
        "defaults": [],
        "code": "    def of(cls, ccy1: Currency, ccy2: Currency, date: Date, value: Decimal) -> \"FXRate\":\n        \"\"\"\n        Creates and returns an FX rate instance by validating arguments.\n\n        >>> import datetime\n        >>> from decimal import Decimal\n        >>> from pypara.currencies import Currencies\n        >>> urate = FXRate(Currencies[\"EUR\"], Currencies[\"USD\"], datetime.date.today(), Decimal(\"2\"))\n        >>> srate = FXRate.of(Currencies[\"EUR\"], Currencies[\"USD\"], datetime.date.today(), Decimal(\"2\"))\n        >>> urate == srate\n        True\n        \"\"\"\n        ## All argument must be of the respective specified type:\n        if not isinstance(ccy1, Currency):\n            raise ValueError(\"CCY/1 must be of type `Currency`.\")\n        if not isinstance(ccy2, Currency):\n            raise ValueError(\"CCY/2 must be of type `Currency`.\")\n        if not isinstance(ccy1, Currency):\n            raise ValueError(\"FX rate value must be of type `Decimal`.\")\n        if not isinstance(ccy1, Currency):\n            raise ValueError(\"FX rate date must be of type `date`.\")\n\n        ## Check the value:\n        if value <= ZERO:\n            raise ValueError(\"FX rate value can not be equal to or less than `zero`.\")\n\n        ## Check consistency:\n        if ccy1 == ccy2 and value != ONE:\n            raise ValueError(\"FX rate to the same currency must be `one`.\")\n\n        ## Create and return the FX rate instance:\n        return cls(ccy1, ccy2, date, value)",
        "class": "FXRate",
        "file": "input/pypara/exchange.py"
    },
    {
        "name": "query",
        "docstring": "Returns the foreign exchange rate of a given currency pair as of a given date.\n\n:param ccy1: The first currency of foreign exchange rate.\n:param ccy2: The second currency of foreign exchange rate.\n:param asof: Temporal dimension the foreign exchange rate is effective as of.\n:param strict: Indicates if we should raise a lookup error if that the foreign exchange rate can not be found.\n:return: The foreign exhange rate as a :class:`Decimal` instance or None.",
        "args": [
            "self",
            "ccy1",
            "ccy2",
            "asof",
            "strict"
        ],
        "defaults": [
            "False"
        ],
        "code": "    def query(self, ccy1: Currency, ccy2: Currency, asof: Date, strict: bool = False) -> Optional[FXRate]:\n        \"\"\"\n        Returns the foreign exchange rate of a given currency pair as of a given date.\n\n        :param ccy1: The first currency of foreign exchange rate.\n        :param ccy2: The second currency of foreign exchange rate.\n        :param asof: Temporal dimension the foreign exchange rate is effective as of.\n        :param strict: Indicates if we should raise a lookup error if that the foreign exchange rate can not be found.\n        :return: The foreign exhange rate as a :class:`Decimal` instance or None.\n        \"\"\"\n        pass",
        "class": "FXRateService",
        "file": "input/pypara/exchange.py"
    },
    {
        "name": "queries",
        "docstring": "Returns foreign exchange rates for a given collection of currency pairs and dates.\n\n:param queries: An iterable of :class:`Currency`, :class:`Currency` and :class:`Temporal` tuples.\n:param strict: Indicates if we should raise a lookup error if that the foreign exchange rate can not be found.\n:return: An iterable of rates.",
        "args": [
            "self",
            "queries",
            "strict"
        ],
        "defaults": [
            "False"
        ],
        "code": "    def queries(self, queries: Iterable[TQuery], strict: bool = False) -> Iterable[Optional[FXRate]]:\n        \"\"\"\n        Returns foreign exchange rates for a given collection of currency pairs and dates.\n\n        :param queries: An iterable of :class:`Currency`, :class:`Currency` and :class:`Temporal` tuples.\n        :param strict: Indicates if we should raise a lookup error if that the foreign exchange rate can not be found.\n        :return: An iterable of rates.\n        \"\"\"\n        pass",
        "class": "FXRateService",
        "file": "input/pypara/exchange.py"
    },
    {
        "name": "__init__",
        "docstring": "Initializes a currency lookup error.",
        "args": [
            "self",
            "code"
        ],
        "defaults": [],
        "code": "    def __init__(self, code: str) -> None:\n        \"\"\"\n        Initializes a currency lookup error.\n        \"\"\"\n        ## Keep the code:\n        self.code = code\n\n        ## Set the message:\n        super().__init__(f\"Currency identified by code '{code}' does not exist\")",
        "class": "CurrencyLookupError",
        "file": "input/pypara/currencies.py"
    },
    {
        "name": "__eq__",
        "docstring": "Checks if the `self` and `other` are same currencies.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __eq__(self, other: Any) -> bool:\n        \"\"\"\n        Checks if the `self` and `other` are same currencies.\n        \"\"\"\n        return isinstance(other, Currency) and self.hashcache == other.hashcache",
        "class": "Currency",
        "file": "input/pypara/currencies.py"
    },
    {
        "name": "__hash__",
        "docstring": "Returns the pre-computed and cached hash.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __hash__(self) -> int:\n        \"\"\"\n        Returns the pre-computed and cached hash.\n        \"\"\"\n        return self.hashcache",
        "class": "Currency",
        "file": "input/pypara/currencies.py"
    },
    {
        "name": "quantize",
        "docstring": "Quantizes the decimal ``qty`` wrt to ccy's minor units fraction. Note that\nthe [ROUND HALF TO EVEN](https://en.wikipedia.org/wiki/Rounding) method\nis used for rounding purposes.\n\n**Note** that the HALF-TO-EVEN method is inherited from the default decimal context instead of\nexplicitly passing it. Therefore, if call-site application is making changes to the default\ncontext, the rounding method may not be HALF-TO-EVEN anymore.",
        "args": [
            "self",
            "qty"
        ],
        "defaults": [],
        "code": "    def quantize(self, qty: Decimal) -> Decimal:\n        \"\"\"\n        Quantizes the decimal ``qty`` wrt to ccy's minor units fraction. Note that\n        the [ROUND HALF TO EVEN](https://en.wikipedia.org/wiki/Rounding) method\n        is used for rounding purposes.\n\n        **Note** that the HALF-TO-EVEN method is inherited from the default decimal context instead of\n        explicitly passing it. Therefore, if call-site application is making changes to the default\n        context, the rounding method may not be HALF-TO-EVEN anymore.\n        \"\"\"\n        return qty.quantize(self.quantizer)",
        "class": "Currency",
        "file": "input/pypara/currencies.py"
    },
    {
        "name": "of",
        "docstring": "Attempts to create a currency instance and returns it.",
        "args": [
            "cls",
            "code",
            "name",
            "decimals",
            "ctype"
        ],
        "defaults": [],
        "code": "    def of(cls, code: str, name: str, decimals: int, ctype: CurrencyType) -> \"Currency\":\n        \"\"\"\n        Attempts to create a currency instance and returns it.\n        \"\"\"\n        ## Check the code:\n        ProgrammingError.passert(isinstance(code, str), \"Currency code must be a string\")\n        ProgrammingError.passert(code.isalpha(), \"Currency code must contain only alphabetic characters\")\n        ProgrammingError.passert(code.isupper(), \"Currency code must be all uppercase\")\n\n        ## Check the name:\n        ProgrammingError.passert(isinstance(name, str), \"Currency name must be a string\")\n        ProgrammingError.passert(name != \"\", \"Currency name can not be empty\")\n        ProgrammingError.passert(not (name.startswith(\" \") or name.endswith(\" \")), \"Trim the currency name\")\n\n        ## Check the decimals:\n        ProgrammingError.passert(isinstance(decimals, int), \"Number of decimals must be an integer\")\n        ProgrammingError.passert(decimals >= -1, \"Number of decimals can not be less than -1\")\n\n        ## Check the type:\n        ProgrammingError.passert(isinstance(ctype, CurrencyType), \"Currency Type must be of type `CurrencyType`\")\n\n        ## Define the quantizer:\n        if decimals > 0:\n            quantizer = make_quantizer(decimals)\n        elif decimals < 0:\n            quantizer = MaxPrecisionQuantizer\n        else:\n            quantizer = ZERO\n\n        ## By now, we should have all required instance attributes. However, we want to compute and cache the hash.\n        hashcode = hash((code, name, decimals, ctype, quantizer))\n\n        ## Done, create the currency object and return:\n        return Currency(code, name, decimals, ctype, quantizer, hashcode)",
        "class": "Currency",
        "file": "input/pypara/currencies.py"
    },
    {
        "name": "__new__",
        "docstring": "Creates the singleton instance, or returns the existing one.",
        "args": [
            "cls"
        ],
        "defaults": [],
        "code": "    def __new__(cls) -> \"CurrencyRegistry\":\n        \"\"\"\n        Creates the singleton instance, or returns the existing one.\n        \"\"\"\n        ## Do we have the singleton instance?\n        if CurrencyRegistry.__instance is None:\n            ## Nope, not yet. Creat one:\n            CurrencyRegistry.__instance = object.__new__(cls)\n\n        ## Return the singleton instance.\n        return CurrencyRegistry.__instance",
        "class": "CurrencyRegistry",
        "file": "input/pypara/currencies.py"
    },
    {
        "name": "__init__",
        "docstring": "Initializes the currency registry.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __init__(self) -> None:\n        \"\"\"\n        Initializes the currency registry.\n        \"\"\"\n        ## Initialize the master registry container.\n        self.__registry: Dict[str, Currency] = OrderedDict([])\n\n        ## Initialize the currencies buffer.\n        self.__currencies: List[Currency] = []\n\n        ## Initialize the currency codes buffer.\n        self.__codes: List[str] = []\n\n        ## Initialize the code/name tuples buffer.\n        self.__codenames: List[Tuple[str, str]] = []\n\n        ## Define the registry population context open/close flag.\n        self.__ctx_open: bool = False",
        "class": "CurrencyRegistry",
        "file": "input/pypara/currencies.py"
    },
    {
        "name": "__enter__",
        "docstring": "Enters the registry population context.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __enter__(self) -> Callable[[Currency], None]:\n        \"\"\"\n        Enters the registry population context.\n        \"\"\"\n        ## Mark the context as open:\n        self.__ctx_open = True\n\n        ## OK, return the add method:\n        return self.__register",
        "class": "CurrencyRegistry",
        "file": "input/pypara/currencies.py"
    },
    {
        "name": "__exit__",
        "docstring": "Exits the registry population context and performs some finalization tasks.",
        "args": [
            "self",
            "exc_type",
            "exc_value",
            "tracebackx"
        ],
        "defaults": [],
        "code": "    def __exit__(self, exc_type: Optional[Type[Exception]], exc_value: Optional[str], tracebackx: Any) -> None:\n        \"\"\"\n        Exits the registry population context and performs some finalization tasks.\n        \"\"\"\n        ## Re-sort the registry:\n        self.__registry = OrderedDict([(c.code, c) for c in sorted(self.__registry.values(), key=lambda x: x.code)])\n\n        ## Re-sort currencies buffer:\n        self.__currencies = [c for c in self.__registry.values()]\n\n        ## Re-sort the currency codes buffer:\n        self.__codes = [c.code for c in self.__currencies]\n\n        ## Re-sort the choices buffer\n        self.__codenames = [(c.code, c.name) for c in self.__currencies]\n\n        ## Close the context:\n        self.__ctx_open = False",
        "class": "CurrencyRegistry",
        "file": "input/pypara/currencies.py"
    },
    {
        "name": "__register",
        "docstring": "Attempts to add the currency to the registry.",
        "args": [
            "self",
            "currency"
        ],
        "defaults": [],
        "code": "    def __register(self, currency: Currency) -> None:\n        \"\"\"\n        Attempts to add the currency to the registry.\n        \"\"\"\n        ## Check of the registry population context is open:\n        if not self.__ctx_open:\n            ## Nope, raise error:\n            raise ProgrammingError(\"Can not create currencies outside registry context.\")\n\n        ## Check if the currency is already added:\n        if currency.code in self.__registry:\n            raise ValueError(f\"Currency {currency.code} is already registered.\")\n\n        ## Add to the containers:\n        self.__registry[currency.code] = currency",
        "class": "CurrencyRegistry",
        "file": "input/pypara/currencies.py"
    },
    {
        "name": "__len__",
        "docstring": "Returns the number of registered currencies.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __len__(self) -> int:\n        \"\"\"\n        Returns the number of registered currencies.\n        \"\"\"\n        return len(self.__registry)",
        "class": "CurrencyRegistry",
        "file": "input/pypara/currencies.py"
    },
    {
        "name": "__contains__",
        "docstring": "Checks if a given currency code is available.",
        "args": [
            "self",
            "code"
        ],
        "defaults": [],
        "code": "    def __contains__(self, code: str) -> bool:\n        \"\"\"\n        Checks if a given currency code is available.\n        \"\"\"\n        return code in self.__registry",
        "class": "CurrencyRegistry",
        "file": "input/pypara/currencies.py"
    },
    {
        "name": "__getitem__",
        "docstring": "Returns the currency identified by the code or raises lookup error.",
        "args": [
            "self",
            "code"
        ],
        "defaults": [],
        "code": "    def __getitem__(self, code: str) -> Currency:\n        \"\"\"\n        Returns the currency identified by the code or raises lookup error.\n        \"\"\"\n        try:\n            return self.__registry[code]\n        except KeyError:\n            raise CurrencyLookupError(code)",
        "class": "CurrencyRegistry",
        "file": "input/pypara/currencies.py"
    },
    {
        "name": "has",
        "docstring": "Indicates if the code is a valid currency code.",
        "args": [
            "self",
            "code"
        ],
        "defaults": [],
        "code": "    def has(self, code: str) -> bool:\n        \"\"\"\n        Indicates if the code is a valid currency code.\n        \"\"\"\n        return code in self.__registry",
        "class": "CurrencyRegistry",
        "file": "input/pypara/currencies.py"
    },
    {
        "name": "get",
        "docstring": "Returns the currency for the given code.\n\nNote that if the code is not a valid currency code, a currency lookup error is raised.",
        "args": [
            "self",
            "code",
            "default"
        ],
        "defaults": [
            "None"
        ],
        "code": "    def get(self, code: str, default: Optional[Currency] = None) -> Optional[Currency]:\n        \"\"\"\n        Returns the currency for the given code.\n\n        Note that if the code is not a valid currency code, a currency lookup error is raised.\n        \"\"\"\n        return self.__registry.get(code, default)",
        "class": "CurrencyRegistry",
        "file": "input/pypara/currencies.py"
    },
    {
        "name": "all",
        "docstring": "Returns the list of currencies.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def all(self) -> List[\"Currency\"]:\n        \"\"\"\n        Returns the list of currencies.\n        \"\"\"\n        return self.__currencies",
        "class": "CurrencyRegistry",
        "file": "input/pypara/currencies.py"
    },
    {
        "name": "codes",
        "docstring": "Returns a list of codes.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def codes(self) -> List[str]:\n        \"\"\"\n        Returns a list of codes.\n        \"\"\"\n        return self.__codes",
        "class": "CurrencyRegistry",
        "file": "input/pypara/currencies.py"
    },
    {
        "name": "codenames",
        "docstring": "Returns a list of code/name tuples.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def codenames(self) -> List[Tuple[str, str]]:\n        \"\"\"\n        Returns a list of code/name tuples.\n        \"\"\"\n        return self.__codenames",
        "class": "CurrencyRegistry",
        "file": "input/pypara/currencies.py"
    },
    {
        "name": "__lt__",
        "docstring": "Provides a comparison for account type enums.",
        "args": [
            "self",
            "other"
        ],
        "defaults": [],
        "code": "    def __lt__(self, other: \"AccountType\") -> bool:\n        \"\"\"\n        Provides a comparison for account type enums.\n        \"\"\"\n        ## Provides the order of enums:\n        order: Dict[\"AccountType\", int] = {\n            AccountType.ASSETS: 0,\n            AccountType.LIABILITIES: 1,\n            AccountType.EQUITIES: 2,\n            AccountType.REVENUES: 3,\n            AccountType.EXPENSES: 4,\n        }\n\n        ## Compare and return the order of enums:\n        return order[self] < order[other]",
        "class": "AccountType",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "code",
        "docstring": "Code of the account.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def code(self) -> Code:\n        \"\"\"\n        Code of the account.\n        \"\"\"\n        ...",
        "class": "Account",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "name",
        "docstring": "Name of the account.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def name(self) -> str:\n        \"\"\"\n        Name of the account.\n        \"\"\"\n        ...",
        "class": "Account",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "type",
        "docstring": "Type of the account.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def type(self) -> AccountType:\n        \"\"\"\n        Type of the account.\n        \"\"\"\n        ...",
        "class": "Account",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "coa",
        "docstring": "Chart of accounts of the account.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def coa(self) -> \"COA\":\n        \"\"\"\n        Chart of accounts of the account.\n        \"\"\"\n        ...",
        "class": "Account",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "parent",
        "docstring": "Parent of the account, if any.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def parent(self) -> Optional[\"Account\"]:\n        \"\"\"\n        Parent of the account, if any.\n        \"\"\"\n        ...",
        "class": "Account",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "parent",
        "docstring": "Parent account.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def parent(self) -> Optional[\"Account\"]:\n        \"\"\"\n        Parent account.\n        \"\"\"\n        ## I wish I could do `parent: ClassVar[Optional[\"Account\"]] = None` instead!\n        return None",
        "class": "RootAccount",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "type",
        "docstring": "Type of the account.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def type(self) -> AccountType:\n        \"\"\"\n        Type of the account.\n        \"\"\"\n        return self.parent.type",
        "class": "SubAccount",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "coa",
        "docstring": "Chart of accounts the account belongs to.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def coa(self) -> \"COA\":\n        \"\"\"\n        Chart of accounts the account belongs to.\n        \"\"\"\n        return self.parent.coa",
        "class": "SubAccount",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "__post_init__",
        "docstring": "Initializes the root accounts buffer.",
        "args": [
            "self",
            "rootspec"
        ],
        "defaults": [],
        "code": "    def __post_init__(self, rootspec: Optional[Dict[AccountType, Tuple[Code, str]]]) -> None:\n        \"\"\"\n        Initializes the root accounts buffer.\n        \"\"\"\n        ## Do we have a rootspec?\n        rootspec = rootspec or {}\n\n        ## Iterate over account types and initialize root accounts:\n        for c, t in enumerate(AccountType, start=1):\n            ## Attempt to get or initialize code/name tuple for the type:\n            code, name = rootspec.get(t, (Code(str(c)), t.name.capitalize()))\n\n            ## Create the account and add to the buffer:\n            self._accounts[code] = RootAccount(code, name, t, self)",
        "class": "COA",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "__iter__",
        "docstring": "Returns an iterable of account code and account tuples.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __iter__(self) -> Iterator[Tuple[Code, Account]]:\n        \"\"\"\n        Returns an iterable of account code and account tuples.\n        \"\"\"\n        return ((c, a) for c, a in self._accounts.items())",
        "class": "COA",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "accounts",
        "docstring": "All accounts of the chart of accounts.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def accounts(self) -> Iterable[Account]:\n        \"\"\"\n        All accounts of the chart of accounts.\n        \"\"\"\n        return iter(self._accounts.values())",
        "class": "COA",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "toplevel",
        "docstring": "Top-level accounts (balance sheet and income statement accounts) of the chart of accounts.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def toplevel(self) -> Iterable[Account]:\n        \"\"\"\n        Top-level accounts (balance sheet and income statement accounts) of the chart of accounts.\n        \"\"\"\n        return (a for a in self.accounts if a.parent is None)",
        "class": "COA",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "structure",
        "docstring": "Tree-like structure of the chart of accounts.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def structure(self) -> Iterable[\"COA.Node\"]:\n        \"\"\"\n        Tree-like structure of the chart of accounts.\n        \"\"\"\n        return map(self.nodify, self.toplevel)",
        "class": "COA",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "find",
        "docstring": "Attempts to find and return the account by the given code.\n\n:param code: Code of the account we want to retrieve.\n:return: :py:class:`Account` identified by the given code if found, ``None`` otherwise.",
        "args": [
            "self",
            "code"
        ],
        "defaults": [],
        "code": "    def find(self, code: Code) -> Optional[Account]:\n        \"\"\"\n        Attempts to find and return the account by the given code.\n\n        :param code: Code of the account we want to retrieve.\n        :return: :py:class:`Account` identified by the given code if found, ``None`` otherwise.\n        \"\"\"\n        return self._accounts.get(code, None)",
        "class": "COA",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "subaccounts",
        "docstring": "Attempts to find and return sub-accounts of the given account.\n\n:param account: Account we want to retrieve sub-accounts of.\n:return: List of sub-accounts.",
        "args": [
            "self",
            "account"
        ],
        "defaults": [],
        "code": "    def subaccounts(self, account: Account) -> List[Account]:\n        \"\"\"\n        Attempts to find and return sub-accounts of the given account.\n\n        :param account: Account we want to retrieve sub-accounts of.\n        :return: List of sub-accounts.\n        \"\"\"\n        return self._subaccounts.get(account, [])",
        "class": "COA",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "nodify",
        "docstring": "Compiles a :py:class:`Node` instance for the given account.\n\n:param account: Account we want to compile the :py:class:`Node` for.\n:return: Account :py:class:`Node` within the chart of accounts.",
        "args": [
            "self",
            "account"
        ],
        "defaults": [],
        "code": "    def nodify(self, account: Account) -> \"COA.Node\":\n        \"\"\"\n        Compiles a :py:class:`Node` instance for the given account.\n\n        :param account: Account we want to compile the :py:class:`Node` for.\n        :return: Account :py:class:`Node` within the chart of accounts.\n        \"\"\"\n        return self.Node(account, [self.nodify(a) for a in self.subaccounts(account)])",
        "class": "COA",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "add",
        "docstring": "Attempts to add a new account to the chart of accounts.\n\n:param parent: Code of the parent account.\n:param code: Account code.\n:param name: Account name.\n:return: Newly created account (or existing one).",
        "args": [
            "self",
            "parent",
            "code",
            "name"
        ],
        "defaults": [],
        "code": "    def add(self, parent: Code, code: Code, name: str) -> Account:\n        \"\"\"\n        Attempts to add a new account to the chart of accounts.\n\n        :param parent: Code of the parent account.\n        :param code: Account code.\n        :param name: Account name.\n        :return: Newly created account (or existing one).\n        \"\"\"\n        ## Check if parent and code are same:\n        if parent == code:\n            raise ValueError(\"An account can not be the parent of itself.\")\n\n        ## Attempt to get the parent instance:\n        parentinstance = self._accounts.get(parent)\n\n        ## Check if we have a parent instance:\n        if parentinstance is None:\n            raise ValueError(\"Parent account is not (yet) defined.\")\n\n        ## Check if we already have an account:\n        if code in self._accounts:\n            ## Get the account:\n            account = self._accounts[code]\n\n            ## Check account information is consistent:\n            if account.parent == parentinstance and account.name == name and account.code == code:\n                return account\n            else:\n                raise ValueError(\"Account name, code and parent do not match existing chart of accounts member.\")\n\n        ## Create the account:\n        account = SubAccount(code, name, self._accounts[parent])\n\n        ## Add to the COA:\n        self._accounts[code] = account\n\n        ## Add the account to children buffer:\n        if account.parent not in self._subaccounts:\n            self._subaccounts[account.parent] = []\n        self._subaccounts[account.parent].append(account)\n\n        ## Done, return the new account:\n        return account",
        "class": "COA",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "print",
        "docstring": "Prints the chart of accounts in a tree-like form.\n\n:param coa: Chart of accounts to print.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def print(self) -> None:\n        \"\"\"\n        Prints the chart of accounts in a tree-like form.\n\n        :param coa: Chart of accounts to print.\n        \"\"\"\n        for tree in self.structure:\n            self._print_node(tree, 0)",
        "class": "COA",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "_print_node",
        "docstring": "Prints a node.\n\nThis is an auxiliary function to :py:func:`print_coa`.\n\n:param node: Node to print.\n:param level: Level to print node at.",
        "args": [
            "cls",
            "node",
            "level"
        ],
        "defaults": [
            "0"
        ],
        "code": "    def _print_node(cls, node: \"COA.Node\", level: int = 0) -> None:\n        \"\"\"\n        Prints a node.\n\n        This is an auxiliary function to :py:func:`print_coa`.\n\n        :param node: Node to print.\n        :param level: Level to print node at.\n        \"\"\"\n        print(f\"{''.join(['    '] * level)}[{node.account.code}] {node.account.name}\")\n        for c in node.children:\n            cls._print_node(c, level + 1)",
        "class": "COA",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "__call__",
        "docstring": null,
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def __call__(self) -> COA:\n        pass",
        "class": "ReadChartOfAccounts",
        "file": "input/pypara/accounting/accounts.py"
    },
    {
        "name": "date",
        "docstring": "Date of the ledger entry.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date",
        "class": "LedgerEntry",
        "file": "input/pypara/accounting/ledger.py"
    },
    {
        "name": "description",
        "docstring": "Description of the ledger entry.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description",
        "class": "LedgerEntry",
        "file": "input/pypara/accounting/ledger.py"
    },
    {
        "name": "amount",
        "docstring": "Amount of the ledger entry.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount",
        "class": "LedgerEntry",
        "file": "input/pypara/accounting/ledger.py"
    },
    {
        "name": "cntraccts",
        "docstring": "Counter accounts for the ledger entry.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]",
        "class": "LedgerEntry",
        "file": "input/pypara/accounting/ledger.py"
    },
    {
        "name": "is_debit",
        "docstring": "Indicates if the ledger entry is a debit.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit",
        "class": "LedgerEntry",
        "file": "input/pypara/accounting/ledger.py"
    },
    {
        "name": "is_credit",
        "docstring": "Indicates if the ledger entry is a credit.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit",
        "class": "LedgerEntry",
        "file": "input/pypara/accounting/ledger.py"
    },
    {
        "name": "debit",
        "docstring": "Returns the debit amount, if any.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None",
        "class": "LedgerEntry",
        "file": "input/pypara/accounting/ledger.py"
    },
    {
        "name": "credit",
        "docstring": "Returns the credit amount, if any.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None",
        "class": "LedgerEntry",
        "file": "input/pypara/accounting/ledger.py"
    },
    {
        "name": "_last_balance",
        "docstring": "Returns the last balance.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value",
        "class": "Ledger",
        "file": "input/pypara/accounting/ledger.py"
    },
    {
        "name": "add",
        "docstring": "Adds a new ledger entry.\n\n:param posting: Posting the ledger entry is based on.\n:return: The new ledger entry.",
        "args": [
            "self",
            "posting"
        ],
        "defaults": [],
        "code": "    def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry",
        "class": "Ledger",
        "file": "input/pypara/accounting/ledger.py"
    },
    {
        "name": "build_general_ledger",
        "docstring": "Builds a general ledger.\n\n:param period: Accounting period.\n:param journal: All available journal entries.\n:param initial: Opening balances for terminal accounts, if any.\n:return: A :py:class:`GeneralLedger` instance.",
        "args": [
            "period",
            "journal",
            "initial"
        ],
        "defaults": [],
        "code": "def build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)",
        "class": null,
        "file": "input/pypara/accounting/ledger.py"
    },
    {
        "name": "__call__",
        "docstring": null,
        "args": [
            "self",
            "period"
        ],
        "defaults": [],
        "code": "    def __call__(self, period: DateRange) -> InitialBalances:\n        pass",
        "class": "ReadInitialBalances",
        "file": "input/pypara/accounting/ledger.py"
    },
    {
        "name": "__call__",
        "docstring": null,
        "args": [
            "self",
            "period"
        ],
        "defaults": [],
        "code": "    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n        pass",
        "class": "GeneralLedgerProgram",
        "file": "input/pypara/accounting/ledger.py"
    },
    {
        "name": "compile_general_ledger_program",
        "docstring": "Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\na general ledger.\n\n:param read_initial_balances: Algebra implementation which reads initial balances.\n:param read_journal_entries: Algebra implementation which reads journal entries.\n:return: A function which consumes opening and closing dates and produces a general ledger",
        "args": [
            "read_initial_balances",
            "read_journal_entries"
        ],
        "defaults": [],
        "code": "def compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program",
        "class": null,
        "file": "input/pypara/accounting/ledger.py"
    },
    {
        "name": "_program",
        "docstring": "Consumes the opening and closing dates and produces a general ledger.\n\n:param period: Accounting period.\n:return: A general ledger.",
        "args": [
            "period"
        ],
        "defaults": [],
        "code": "    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)",
        "class": null,
        "file": "input/pypara/accounting/ledger.py"
    },
    {
        "name": "of",
        "docstring": "Returns the corresponding direction as per the sign of the quantity.\n\n:param quantity: Quantity to find the direction of.\n:return: Direction for the quantity.\n:raises AssertionError: If quantity is zero which implies a programming error.",
        "args": [
            "cls",
            "quantity"
        ],
        "defaults": [],
        "code": "    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC",
        "class": "Direction",
        "file": "input/pypara/accounting/journaling.py"
    },
    {
        "name": "is_debit",
        "docstring": "Indicates if this posting is a debit.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]",
        "class": "Posting",
        "file": "input/pypara/accounting/journaling.py"
    },
    {
        "name": "is_credit",
        "docstring": "Indicates if this posting is a credit.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit",
        "class": "Posting",
        "file": "input/pypara/accounting/journaling.py"
    },
    {
        "name": "increments",
        "docstring": "Incerement event postings of the journal entry.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)",
        "class": "JournalEntry",
        "file": "input/pypara/accounting/journaling.py"
    },
    {
        "name": "decrements",
        "docstring": "Decrement event postings of the journal entry.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)",
        "class": "JournalEntry",
        "file": "input/pypara/accounting/journaling.py"
    },
    {
        "name": "debits",
        "docstring": "Debit postings of the journal entry.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)",
        "class": "JournalEntry",
        "file": "input/pypara/accounting/journaling.py"
    },
    {
        "name": "credits",
        "docstring": "Credit postings of the journal entry.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)",
        "class": "JournalEntry",
        "file": "input/pypara/accounting/journaling.py"
    },
    {
        "name": "post",
        "docstring": "Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\nIf the quantity is ``0``, nothing is posted.\n\n:param date: Date of posting.\n:param account: Account to post the amount to.\n:param quantity: Signed-value to post to the account.\n:return: This journal entry (to be chained conveniently).",
        "args": [
            "self",
            "date",
            "account",
            "quantity"
        ],
        "defaults": [],
        "code": "    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self",
        "class": "JournalEntry",
        "file": "input/pypara/accounting/journaling.py"
    },
    {
        "name": "validate",
        "docstring": "Performs validations on the instance.\n\n:raises AssertionError: If the journal entry is inconsistent.",
        "args": [
            "self"
        ],
        "defaults": [],
        "code": "    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"",
        "class": "JournalEntry",
        "file": "input/pypara/accounting/journaling.py"
    },
    {
        "name": "__call__",
        "docstring": null,
        "args": [
            "self",
            "period"
        ],
        "defaults": [],
        "code": "    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass",
        "class": "ReadJournalEntries",
        "file": "input/pypara/accounting/journaling.py"
    },
    {
        "name": "make_quantizer",
        "docstring": "Creates a quantifier as per the given precision.",
        "args": [
            "precision"
        ],
        "defaults": [],
        "code": "def make_quantizer(precision: int) -> Decimal:\n    \"\"\"\n    Creates a quantifier as per the given precision.\n    \"\"\"\n    return Decimal(f\"0.{''.join(['0' * precision])}\")",
        "class": null,
        "file": "input/pypara/commons/numbers.py"
    },
    {
        "name": "isum",
        "docstring": "Computes the sum of an iterable of :py:class:`DecimalLike` values such as :py:class:`Amount` or\n:py:class:`Quantity` including :py:class:`Decimal` itself.\n\nThe return type is the same as the input element type. The base condition is :py:const:`ZERO` of\n:py:class:`decimal.Decimal` type but cast to the type variable if required.\n\n:param xs: An iterable of :py:class:`Decimal`-like values.\n:param start: Optional initial value. This defaults to :py:const:`ZERO` in the implementation.\n:return: Sum of the elements in the same type as the elements in the argument.\n\n>>> isum([Amount(ONE), Amount(ONE)])  # Return value is of type `Amount` during type-checking.\nDecimal('2')\n>>> isum([Quantity(ONE), Quantity(ONE)])  # Return value is of type `Quantity` during type-checking.\nDecimal('2')\n>>> isum([Amount(ONE), Amount(ONE)], Amount(ONE))  # Return value is of type `Amount` during type-checking.\nDecimal('3')\n>>> isum([Quantity(ONE), Quantity(ONE)], Quantity(ONE))  # Return value is of type `Quantity` during type-checking.\nDecimal('3')",
        "args": [
            "xs",
            "start"
        ],
        "defaults": [
            "None"
        ],
        "code": "def isum(xs: Iterable[DecimalLike], start: Optional[DecimalLike] = None) -> DecimalLike:\n    \"\"\"\n    Computes the sum of an iterable of :py:class:`DecimalLike` values such as :py:class:`Amount` or\n    :py:class:`Quantity` including :py:class:`Decimal` itself.\n\n    The return type is the same as the input element type. The base condition is :py:const:`ZERO` of\n    :py:class:`decimal.Decimal` type but cast to the type variable if required.\n\n    :param xs: An iterable of :py:class:`Decimal`-like values.\n    :param start: Optional initial value. This defaults to :py:const:`ZERO` in the implementation.\n    :return: Sum of the elements in the same type as the elements in the argument.\n\n    >>> isum([Amount(ONE), Amount(ONE)])  # Return value is of type `Amount` during type-checking.\n    Decimal('2')\n    >>> isum([Quantity(ONE), Quantity(ONE)])  # Return value is of type `Quantity` during type-checking.\n    Decimal('2')\n    >>> isum([Amount(ONE), Amount(ONE)], Amount(ONE))  # Return value is of type `Amount` during type-checking.\n    Decimal('3')\n    >>> isum([Quantity(ONE), Quantity(ONE)], Quantity(ONE))  # Return value is of type `Quantity` during type-checking.\n    Decimal('3')\n    \"\"\"\n    return sum(xs, start or cast(DecimalLike, ZERO))",
        "class": null,
        "file": "input/pypara/commons/numbers.py"
    },
    {
        "name": "passert",
        "docstring": "Raises a :py:class:`ProgrammingError` if the condition is ``False``.\n\n:param condition: Indicates if the expectation is fulfilled.\n:param message: Message of the error to be raised in case that the condition is not met.\n:raises ProgrammingError: In case that the condition is ``False``.",
        "args": [
            "cls",
            "condition",
            "message"
        ],
        "defaults": [],
        "code": "    def passert(cls, condition: bool, message: Optional[str]) -> None:\n        \"\"\"\n        Raises a :py:class:`ProgrammingError` if the condition is ``False``.\n\n        :param condition: Indicates if the expectation is fulfilled.\n        :param message: Message of the error to be raised in case that the condition is not met.\n        :raises ProgrammingError: In case that the condition is ``False``.\n        \"\"\"\n        if not condition:\n            raise cls(message or \"Broken coherence. Check your code against domain logic to fix it.\")",
        "class": "ProgrammingError",
        "file": "input/pypara/commons/errors.py"
    },
    {
        "name": "makeguid",
        "docstring": "Creates a new :py:class:`Guid`.\n\n:return: :py:class:`Guid` instance.",
        "args": [],
        "defaults": [],
        "code": "def makeguid() -> Guid:\n    \"\"\"\n    Creates a new :py:class:`Guid`.\n\n    :return: :py:class:`Guid` instance.\n    \"\"\"\n    return Guid(uuid4().hex)",
        "class": null,
        "file": "input/pypara/commons/others.py"
    },
    {
        "name": "identity",
        "docstring": "Provides the identity function.\n\n:param x: Any value of the generic type.\n:return: The value consumed.",
        "args": [
            "x"
        ],
        "defaults": [],
        "code": "def identity(x: _T) -> _T:\n    \"\"\"\n    Provides the identity function.\n\n    :param x: Any value of the generic type.\n    :return: The value consumed.\n    \"\"\"\n    return x",
        "class": null,
        "file": "input/pypara/commons/others.py"
    }
]